// ANOTACIONES

|| PSEUDOCÓDIGO:

	Pensar como se crea o puede llegar a crear cada objeto.

	Las instrucciones (comandos, órdenes) basicas:
	
	entrada:

		Recibir datos del teclado, o un archivo u otro aparato.

	salida:

		Mostrar datos en el monitor o enviar datos a un archivo u otro aparato.

	matemáticas:

	 	Operaciones básicas de matemáticas como la adición y la multiplicación.

	operación condicional:

		Probar la veracidad de alguna condición y ejecutar una secuencia de instrucciones apropiada.

	repetición: 

		Ejecutar alguna acción repetidas veces, normalmente con alguna variación.


|| CREAR FUNCIONES:

	encapsular: 

		Meter el código que crea los objetos en las definiciones de función.


	generalizar:

		Crear variables genericas  en el cuerpo de la función, sin valores determinados para pasarles valores en la llamada.

		Así los objetos son diferentes en dimensiones, formas, aspecto, etc.


	diseño de interfaz:

		Explica como se utiliza la función: 

			¿cuáles son los parámetros? 

			¿Qué hace la función? 

			¿Y cuál es el valor de retorno? 

		Una interfaz es “limpia” si permite a la sentencia llamadora hacer lo que quiere sin lidiar con detalles innecesarios.		

	refactorización:

		Reorganizar un programa para mejorar las interfaces y facilitar la reutilización de código. 


	depuración:

		Corregir errores es programar.


			hipótesis:

				Con una hipostesis correcta podemos predecir comportamientos para modificar el programa y llegar a un resultado correcto o esperado.

				Hay que leer el código, entender cada línea para corregir los errores.


			flujo de ejecución:

				sentencias/def función > sentencias > llamada función (<< sentenc función) > sentencias.

				*leer flujo, no de inicio a fin.


|| PLAN DE DESARROLLO

	un proceso para escribir programas.

		Ej: “encapsulamiento y generalización”.

		1. Comenzar escribiendo un programa pequeño sin definiciones de función.

		2. Una vez que el programa funciona, identifica una parte coherente, encapsula la parte en una función y dale un nombre.

		3. Generaliza la función agregando parámetros apropiados.
	
		4. Repite los pasos 1–3 hasta que tengas un conjunto de funciones eficaces. Copia y pega código que funcione para evitar repetir (y volver a depurar).

		5. Busca oportunidades para mejorar el programa refactorizando. Por ejemplo, si tienes código similar en muchos lugares, considera factorizarlo dentro de una función
		general apropiada.


|| TÉCNICAS
	
	Paso a paso:

		Escribir las ideas que vamos aplicar en cada línea de código, paso a paso; antes de escribir una variable, función, etc.

		Esto nos dará una idea general sobre como empezar el programa.

		Dividir el programa en muchas funciones, cada una debería hacer una sola cosa.


	Abtraer problemas:

		Leer y pensar en el problema, sin programar.

		Hacer pruebas son entradas simples que nos de una salida esperada.

		Buscar patrones, escribir el algoritmo a alto nivel.

		Ir iterando cada vez más a bajo nivel.

		Una vez con la solución, encontrar cosas para mejorar, patrones para abstraer; herramientas del lenguaje que nos ayuden.

		No hay una sola posible solución, primero hacemos que funciones, despues lo hacemos legible.


	Autoevaluación:

		Cosas que no entendemos, Por qué es?, Qué conceptos están en juego? Que no los tenemos claro.

		Probar otras cosas y ver las consecuencias. Fallas en el razonamiento, Cuales? Por qué?

		Entender el tema, las operaciones, los pasos a seguir y ejecutarlos.


	Implementación avanzada:

		A veces resolvemos un problema pero que para un nivel inicial.

		Pero podemos usar conceptos avanzados: estructuras de control correctas, que el código sea eficiente (complejidad, orden de ejecución), código limpio, legible, modular, estructuras de datos.



|| BUENAS PRACTICAS:
	
	Escribir las variables, const, func y documentar en inglés.

	Crear formulas en variables para pasarselas a las funciones, metodos nativos o creadas, etc.

	import math, al inicio del programa.



|| INTERFAZ
	




|| ESTRUCTURA DE DATOS

	Se utilizan para organizar y almacenar información de manera eficiente.

		Cadena/String (cadena de caracter): 



		Vector/Matriz/Array (formación o matrix): 

			Es una cantidad de elementos en un orden específico, generalmente todos del mismo tipo (según el lenguaje, los elementos individuales pueden verse forzados a ser del mismo tipo o pueden ser de casi cualquier tipo).

			Pueden ser de longitud fija o de tamaño variable.


		Listas/List/Linked list: 

			Es una colección ordenada de elementos, donde cada elemento se identifica por un índice.

			Son versatiles y pueden contener elementos de diferentes tipos de datos. 

			Se utilizan para almacenar y manipular conjuntos de datos de manera flexible.

			La principal ventaja de una lista enlazada sobre una matriz es que los valores siempre se pueden insertar y eliminar de manera eficiente sin reubicar el resto de la lista.


		Tuplas/celdas/Tuple/record/estructure (registros o estructura/struct-structure/rows): 

			Es un valor que contiene otros valores, normalmente en un número y una secuencia fijos y normalmente indexados por nombres. Los elementos de los registros suelen denominarse campos o miembros (fields or members).

			Similares a las listas, pero son inmutables, no se pueden modificar después de su creación. 

			Se utilizan para almacenar un conjunto de valores relacionados y se accede a ellos mediante índices.


		Diccionario/hash table (vector asiciativo o mapa/hash): 

			Almacenan elementos como pares clave-valor. Cada elemento se identifica por una clave única y se puede acceder al valor correspondiente utilizando esa clave. 

			Utilizan una función hash para asignar claves a índices en una matriz, lo que permite un acceso en tiempo constante en el caso promedio.

			Son útiles cuando necesitas almacenar y recuperar datos de forma rápida y eficiente utilizando una clave personalizada. 

			Pueden ocurrir colisiones (collisions) de hash, lo que puede afectar su rendimiento. Se emplean técnicas como el encadenamiento y el direccionamiento (chaining and open addressing) abierto para manejar las colisiones.


		Conjuntos/sets:

			Es una colección desordenada de elementos únicos.

			Se utilizan cuando necesitas almacenar elementos sin duplicados y realizar operaciones como intersección, unión y diferencia de conjuntos de manera eficiente.


		Colas/queues: 

			Es una estructura de datos donde el primer elemento que se agrega es el primero en ser eliminado (FIFO: First-In, First-Out).

			Se utilizan para mantener un orden de elementos y son útiles en situaciones donde el orden de llegada es importante, como la gestión de tareas en un sistema.


		Pilas/Stacks: 

			Es una estructura de datos donde el último elemento que se agrega es el primero en ser eliminado (LIFO: Last-In, First-Out).

			Se utilizan para realizar operaciones como deshacer/rehacer, seguimiento de llamadas de funciones y otras situaciones en las que el último elemento agregado es el más relevante.


		Árboles/Trees: 

			Es una estructura de datos no lineal compuesta por nodos. Cada nodo puede tener cero o más nodos hijos.

			Se utilizan en muchas aplicaciones, como estructuras de búsqueda, representación de jerarquías y algoritmos de recorrido.


		Grafos/Graph: 

			Es una estructura de datos compuesta por vértices y aristas que conectan los vértices. 

			Los grafos se utilizan para representar relaciones y conexiones entre elementos.


		Clases/Class: 

			Es una plantilla para la creación de objetos de datos según un modelo predefinido. 

			Las clases se utilizan como representación abstracta de conceptos, incluyen campos como los registros y operaciones que pueden consultar el valor de los campos o cambiar sus valores.


	Python: 

		Tiene una jerarquía estandarizada: 



		Ejemplos: 





|| POO


