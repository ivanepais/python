 	|| INTRO

Los cientı́ficos informáticos usan lenguajes formales para designar ideas (especı́fica-
mente, computaciones).

Los ingenieros, ellos diseñan cosas, ensamblando
sistemas a partir de componentes y evaluando ventajas y desventajas de cada
una de las alternativas. Como los cientı́ficos, ellos observan el comportamiento
de sistemas complejos, forman hipótesis, y prueban sus predicciones.

La solución de problemas incluye poder formular problemas, pensar en
la solución de manera creativa, y expresar una solución con claridad y precisión.


	|| LEGUAJES DE ALTO Y BAJO NIVEL: INTERPRETADOS Y COMPILADOS

los computadores sólo ejecutan programas escritos en lenguajes de bajo nivel. Los programas de alto
nivel tienen que traducirse antes de ejecutarse. Lleva tiempo, lo
cual es una pequeña desventaja.

la programación en lenguajes
de alto nivel es mucho más fácil; toma menos tiempo, los programas son más cortos y más fáciles de leer,
son portables, lo que significa que pueden ejecutarse en tipos
diferentes de computadores.

Los programas escritos en lenguajes de bajo nivel sólo pueden ser ejecutarse en
un tipo de computador y deben reescribirse para ejecutarlos en otro.

tipos de programas que traducen lenguajes de alto nivel a lenguajes
de bajo nivel: intérpretes y compiladores.

intérprete lee un programa de
alto nivel y lo ejecuta, Traduce el programa poco a poco, leyendo y ejecutando cada comando.
	
	codigo fuente -> interprete -> salida

Un compilador lee el programa y lo traduce todo al mismo tiempo, antes de
ejecutar cualquiera de las instrucciones.
	
	codigo fuente -> compilador -> codigo objeto -> ejecutor -> salida

Python es un ejemplar
de un lenguaje de alto nivel como C,
C++, Perl y Java.

Python se considera como lenguaje interpretado porque los programas de Pyt-
hon se ejecutan por medio de un intérprete

intérprete de python: modo de comando y modo de guión.

Comando: 

	$ python    // inicia el intérprete
	Python 1.5.2 (#1, Feb 1 2000, 16:32:16)  // mensajes del intérprete.
	Copyright 1991-1995 Stichting Mathematish Centrum, Amsterdam 
	>>> print 1 + 1  //  intérprete, podemos escribir 
	2  // respuesta interprete

Guión: 
Archivo donde está escrito o vamos a escribir el programa de python. 
en un editor de texto se puede crear un archivo
	
	programa_1.py

	print 1 + 1 // código fuente

ahora debemos ejecutar el programa:
indicar el nombre del guión o archivo al interprete
	
	$ python programa_1.py
	
	2 // salida, respuesta del interprete.


Ventaja la línea de comandados para los ejemplos:
pruebas rápidas porque se pueden teclear las instrucciones de Python y se pue-
den ejecutar inmediatamente.
Una vez que un programa está completo, puede
archivarse en un guión para ejecutarlo o modificarlo en el futuro.

	
	|| PROGRAMA

secuencia de instrucciones especifican cómo ejecutar
una computación que puede ser algo matematico como solucionar un sistema de ecuaciónes

También
puede ser una computación simbólica, como buscar y reemplazar el texto de un
documento o (aunque parezca raro) compilar un programa.

Las instrucciones (comandos, órdenes) basicas:
	
	entrada:
		 Recibir datos del teclado, o un archivo u otro aparato.

	salida:
		 Mostrar datos en el monitor o enviar datos a un archivo u otro aparato.

	matemáticas:
	 	Ejecutar operaciones básicas de matemáticas como la adición y la multiplicación.

	operación condicional:
		 Probar la veracidad de alguna condición y ejecutar una secuencia de instrucciones apropiada.

	repetición: 
		Ejecutar alguna acción repetidas veces, normalmente con alguna variación.

Todos los programas que existen, por complicados que
sean están formulados de esta manera.

	*La clave es dividir una tarea en tareas cada vez más pequeñas
	
	
	|| DEPURACIÓN o DEBUGGING

Los errores en la programación se llaman bugs y la corrección de ellos se llama depuración o debugging.

Tipos de errores:
	
	SINTÁCTICOS
se refiere a
la estructura de cualquier programa y a las reglas de esa estructura.
Python no es tan permisivo. un solo error sintáctico mensaje de error y abortará la ejecución
del programa.

	TIEMPO DE EJECUCIÓN 
no aparece
hasta que se ejecuta el programa
se llaman excepciones
porque indican que algo excepcional (y malo) ha ocurrido.

	SEMÁNTICOS
error de lógica en su
programa, se ejecutará sin ningún mensaje de error, pero el resul-
tado no será el deseado.
requiere trabajar al revés, observando el resultado
del programa para averiguar lo que hace.

	
	|| DEPURACIÓN EXPERIMENTAL

a veces es frustrante, pero es una de las partes más intelectualmente
ricas, interesantes y estimulantes de la programación.

tarea de un investigador: se tie-
nen que estudiar las claves para inducir los procesos y eventos llevaron a los
resultados que tiene a la vista.

Una vez que se tiene la
idea de cuál es el error, se modifica el programa y se intenta nuevamente.

Si su hipótesis fue la correcta se pueden predecir los resultados de la modificación y
estará más cerca de un programa correcto. 

Si su hipótesis fue errónea tendrá que
idearse otra hipótesis.

DEPURACIÓN = PROGRAMACIÓN:
	
la programación es el proceso de depurar un programa gradualmente hasta que haga
lo que usted quiera.	

comenzar con un programa
que haga algo y hacer pequeñas modificaciones, depurándolas sobre la marcha,
de modo que siempre tenga un programa que funcione.


	|| LENGUAJES

naturales 
son los lenguajes hablados por seres humanos, desarrollado naturalmente.

formales
son lenguajes diseñados por humanos y que tienen aplicaciones especı́ficas
	ej: notación matemática, representación de las relaciones entre números y
sı́mbolos.

DE PROGRAMACIÓN
formales desarrollados para expresar computaciones.
	
COMPONENTES:
	
	unidades:
	elementos básicos como las palabras, los números

	estructura:
	la estructura de un elemento; o sea, el orden de las unidades.
	TIENE UNA SERIE DE REGLAS

Diferencias entre naturales y formales: 
	
	AMBIGUEDAD:
	lenguajes naturales tiene muchisimas

	lenguajes formales se diseñan para estar completamente libres de am-
	bigüedades o tanto como sea posible.
	
	REDUNDANCIA:
	los naturales lo usan para reducir la ambigüedad y los malentendidos.
	
	formales son menos redundantes y más concisos.

	LITERALIDAD:
	Los lenguajes naturales tienen muchas metáforas y frases hechas.
	
	formales no difieren de su significado literal.

PROGRAMAS:
 El significado de un programa es inequı́voco y literal, y es enten-
dido en su totalidad analizando las unidades y la estructura. SON DENSOS 

la estructura es muy importante, ası́ que entonces NO es una buena idea
LEERLOS de pies a cabeza, de IZQ a DER. 

En vez de eso, aprenda a: 
SEPARAR LAS DIFERENTES PARTES EN SU MENTE, identificar las unidades e interpretar la
estructura.


	|| PRIMER PROGRAMA

en    py2:     	print "Hola, mundo"                                       en py3:     print('Hola, mundo')        

sentencia print: 
muestra un valor.

	
	|| GLOSARIO

	
	solución de problemas:
		 El proceso de formular un problema, hallar la solu-
		ción y expresar esa solución.

	lenguaje de alto nivel: 
		Un lenguaje como Python diseñado para ser fácil de
		leer y escribir para la gente.

	lenguaje de bajo nivel:
		 Un lenguaje de programación diseñado para ser fácil
		de ejecutar para un computador; también se lo llama “lenguaje de máqui-
		na” o “lenguaje ensamblador”.

	portabilidad: 
		La cualidad de un programa que le permite ser ejecutado en
		más de un tipo de computador.

	interpretar: 
		Ejecutar un programa escrito en un lenguaje de alto nivel tradu-
		ciéndolo lı́nea por lı́nea

	compilar: 
		Traducir un programa escrito en un lenguaje de alto nivel a un len-
		guaje de bajo nivel todo al mismo tiempo, en preparación para la ejecución
		posterior.

	código fuente:
 		Un programa escrito en un lenguaje de alto nivel antes de ser
		compilado.

	código de objeto: 
		La salida del compilador una vez que ha traducido el pro-
		grama.

	programa ejecutable: 
		Otro nombre para el código de objeto que está listo
		para ejecutarse.

	guión: 
		Un programa archivado (que va a ser interpretado).
	
	programa: 
		Un conjunto de instrucciones que especifica una computación.

	algoritmo: 
		Un proceso general para resolver una clase completa de problemas.

	sintaxis: 
		La estructura de un programa.

	error sintáctico: 
		Un error en un programa que hace que el programa sea im-
		posible de analizar sintácticamente (e imposible de interpretar).

	error en tiempo de ejecución: 
		Un error que no ocurre hasta que el progra-
		ma ha comenzado a ejecutarse e impide que el programa continúe.

	excepción: 
		Otro nombre para un error en tiempo de ejecución.

	error semántico: 
		Un error en un programa que hace que ejecute algo que no
		era lo deseado.
	
	semántica:
		 El significado de un programa

	análisis sintáctico: 
		La examinación de un programa y el análisis de su estruc-
		tura sintáctica.

	token: 
		Uno de los elementos básicos de la estructura sintáctica de un programa, análogo a
		una palabra en un lenguaje natural.
	
	tipo:
		 Una categoría de valores. Los tipos que hemos visto hasta ahora son los enteros (tipo
		int ), los números de coma flotante (tipo float ) y cadenas (tipo str ).

	intérprete: 
		Un programa que lee otro programa y lo ejecuta.

	prompt: 
		Caracteres mostrados por el intérprete que indican que está listo para recibir la
		entrada del usuario.

	análisis sintáctico (parse): 
		Examinar un programa y analizar la estructura sintáctica.

	error de programación (bug): Un error en un programa.
		depuración: El proceso de encontrar y corregir errores de programación.
	
	
	|| VARIABLES, EXPRESIONES Y SENTENCIAS

VALOR:
unidad fundamental de la estructura: hay DISTINTOS TIPOS
	
	CADENA o STRING: conjunto de caracteres o letras. CON COMILLAS.

	NÚMERICO o NUMBER: a su vez tienen DISTINTOS TIPOS. SIN COMILLAS.
		
		enteros o int

		decimales o float, van con punto.

	
*Si los numeros van entre comillas se transforman en cadena.
>>> type("17")
<type ’string’>

Comas en numeros:
las interpreta como lista de tres números ( o los que sean) que debe imprimir.

 en py3:  >>> print 1,000,000                                en py2:          >>> print(1,000,000)
1 0 0       													1 0 0


py3 acepta los dos.

	
preguntar al interprete:  PRIMERO INICIAMOS PYTHON en la terminal, escribiendo python

$ python	// inicio

>>> type("Hola, mundo") //  comando,  parentesis para preguntar
<type ’string’> // respuesta

>>> type(17)                                                               en py3:            >>> type(17)
															<class 'int'>
<type ’int’>								//cambia respuesta 


“class” se utiliza en el sentido de una categoría: un tipo es
una categoría de valores.

los enteros pertenecen al tipo int , las cadenas pertenecen al tipo str y los
números de coma flotante pertenecen al tipo float .
	

	|| VARIABLES: 

En C++ una variable es un nombre para un lugar que contiene una cosa. Las
variables deben declararse según su tipo en parte porque el tamaño del lugar al
que apuntan tiene que determinarse de antemano. Ası́, la idea de una variable
está ligada al hardware de la máquina. El concepto poderoso y fundamental

En Python una variable es un nombre que señala una cosa.

Variable y valor:
	
	>>> mensaje =  "que honda?"
	>>> pi = 3.14159

imprimir variables: a print le pasamos su nombre y nos devuelve el valor de la variable.
	
	>>> print mensaje 
	"Que onda?"

	en py3: print (mensaje)
			"Que honda?"

nombres significativos para sus
variables: esto permite documentar para qué se usa la variable.

Bruno y bruno son dos variables diferentes.

El guión bajo ( _ ) múltiples palabras

>>> 76trombones = "gran desfile"
SyntaxError: invalid syntax

*debe comenzar con una letra.

*no se permiten palabras resevadas para variables:
	
	>>> class = "Curso de Programación 101"
	SyntaxError: invalid syntax

Python tiene 28 palabras reservadas:

	and assert break class continue def del elif else except exec finally

	for from global if import in is lambda not or pass print raise return try while

	
	|| SENTENCIAS

instrucción que puede ejecutar el intérprete 
	
	print: muestra el valor de la variable
	asignación de valores: no produce resultado o salida

	
	|| Evaluar expresiones

Una expresión es una combinación de valroes, variables y operadores.

el interprete evalua la expresión y muestra el resultado
	
	>>> 1 + 1
	2

Un valor, y también una variable, se considera una expresión por sı́ mismo.
	
	>>> 17
	17

	>>> x
	2
	

evaluar una expresión no es imprimir un valor

>>> mensaje = "Que onda?"  //definicion de variable

>>> mensaje // evaluación
"Que onda?"

>>> print mensaje 
Que onda?

print muestra el valor o contenido de la variable
la evaluación  muestra toda la estructura, la definición.
 
	Ejercicio: estos valores no se muestran en el interprete
		
			17
			3.2
		"Hola, mundo"
			1 + 1
	*Les falta print (17)


	|| Ejercicios

¿Cuántos segundos hay en 42 minutos con 42 segundos?

print(60*42+42)
>>> 2562

¿Cuántas millas hay en 10 kilómetros? Pista: hay 1.61 kilómetros en una milla.

print(10/1.6)
>>> 6.21

Si corres una carrera de 10 kilómetros en 42 minutos con 42 segundos, ¿Cuál es tu ritmo
promedio (tiempo por cada milla en minutos y segundos)? ¿Cuál es tu rapidez promedio en
millas por hora?

print (42.42/10)
>>> 4.242  #km en promedio
print (42.42/6.21)
>>> 6.83 #ml en prom

	
	|| OPERADORES Y EXPRESIONES

Los operadores son los simbolos y los operandos los valores. 

20+32       hora-1        hora*60+minuto          minuto/60          5**2          (5+9)*(15-7)

Los sı́mbolos +, -, /, y el uso de los paréntesis para el agrupamiento, se usan
todos de la misma forma que en matemáticas. El asterisco (*) es el signo de
multiplicación y ** el sı́mbolo para exponenciación.

	*nombre de una variable es valido entre medio de las operaciones.

>>> minuto = 59
>>> minuto/60
0

59 dividido entre 60 es 0.98333

división de enteros, resultado ha de ser también un entero; simpre se redondea a la baja

Una alternativa posible en este caso es el cálculo de un porcentaje y no el de
una fracción:

>>> minuto*100/60
98
De nuevo se redondea el resultado a la baja,

Otra alternativa es la división de coma flotante, más adelante.

	
	|| ORDEN DE LAS OPERACIONES

PEMDAS :
	
	parentesis
		
		forzar que una expresión se evalue primero: 2 * (3-1)
		
		legible, aunque el resultado no cambie dado su orden.

			(minuto * 100) / 60


	 exponenciación (**)
		
		2**1+1
		
		3*1**3 es igual a 3


	 multiplicación y división:
		
		 misma precedencia, pero más alta que suma y resta
				
			2*3-1
			
*Los operadores que tienen la misma precedencia se evalúan de izquierda
a derecha. Ası́, en la expresión minuto*100/60 = 98 y no 59
	
	
	|| OPERACIONES SOBRE CADENAS

No se puede. Tampoco con una variable que tenga una cadena/ string, como mensaje en el ej.

>>> "Hola"/123         mensaje-1          "15"+2

Para cadenas, el operador + representa la concatenación 

>>> fruta = "plátano"
>>> bizcochoBueno = " pan de leche"
>>> print fruta + bizcochoBueno

*para imprimir dos cadenas, en la segunda debe haber un espacio antes, si no se verán juntas.

----------------
los tres signos mayor es para la consola, en el archivo no hace falta.
----------------

El operador * también funciona con cadenas; lleva a cabo la repetición. Por
ejemplo ’Chiste’*3 es ’ChisteChisteChiste’.

una cadena * un entero.

	Ejercicio: 
propiedad que tienen la suma y la multiplicación de enteros y que no tengan la concatenación
y la repetición de cadenas?

	
	|| COMPOSICIÓN

Combinar variables, expresiones y sentencias que estaban separadas

Los lenguajes de programación tomar pequeños bloques de construcción y ensamblarlos.

Podemos imprimir y sumarlos al mismo tiempo: 
		
		>>> print 17 + 3

		20

Cadena + operación matematica: 
	
	print "Número de minutos desde la medianoche: ", hora*60+minuto

A una variable le podemos asignar una operación:
	
	porcentaje = (minuto * 100) / 60


	|| COMENTARIOS

Es difı́cil observar un trozo de código y averiguar lo que hace, o por qué lo hace.

se marcan con el sı́mbolo #

	# calcula el porcentaje de la hora que ha pasado ya
porcentaje = (minuto * 100) / 60

porcentaje = (minuto * 100) / 60
# ojo: división de enteros

El mensaje está destinado al programador, o a futuros programa-
dores que podrı́an tener que usar el código.


	|| Glosario 2
		
	sentencia:
 		es una porción de código que representa una orden o acción. 
		Hasta ahora, las sentencias que hemos vistos son las asignaciones y las sentencias
		print.

	asignación: 
		sentencia que asigna un valor a una variable.

	diagrama de estado: 
		representación gráfica de un conjunto de variables y de los valores a los que se refiere.

	expresión:
		 una combinación de variables, operadores y valores. Dicha combinación representa un único valor como resultado.

	evaluar:
		 simplificar una expresión ejecutando las operaciones para entregar un valor único.
	
	

	|| FUNCIONES 

“cuando definas una función, empieza con def, seguido del nombre
de la función que estés definiendo; cuando llames a una función, simplemente di
(escribe) su nombre”.
 Los parámetros van con las definiciones; los argumentos
con las llamadas.

No hay tipo de retorno, tipos de parámetros, o parámetro por
referencia y valor de por medio como en C++.

	LLAMADAS:

>>> type("32") 
<type ’string’>

la función es type, y muestra el tipo de un valor o de una variable.

El valor o variable, llamado el argumento de la función, ha de estar encerrado
entre paréntesis.

una función “toma” un argumento y
“devuelve” un resultado, se llama valor de retorno.

	Podemos 	ASIGNAR LA FUNCION A UNA VARIABLE o
	En lugar de imprimir el valor de retorno, podemos asignárselo a una variable.
		
		>>> nereida = type("32")
		>>> print nereida
		<type ’string’>

		>>> func1 = id(3)
		>>> id(func1)
		39199700
		
Funcion id:
la función id toma como argumento un valor o una variable
y devuelve un entero que actúa como identificador único de ese valor.
		
	>>> id(3)
	134882108

	>>> yanira = 3
	>>> id(yanira)
	134882108
	
	>>> func1 = id(3)
	>>> id(func1)
	39199700

es un valor único relacionado con dónde se almacena
en la memoria del computador.
	

	|| Conversion de tipos

La función int toma un valor y lo convierte a un entero, si
es posible, o da un error si no es posible.

	>>> int("32")
	32
	
	>>> int("Hola")
	ValueError: invalid literal for int(): Hola

también convierte valores de coma flotante a enteros, redondeando hacia abajo.
	
	>>> int(3.99999)
	3

La función float que convierte enteros y cadenas en números en coma flotante:
	
	>>> float(32)
	32.0
	
	>>> float("3.14159")
	3.14159

la función str, que convierte a tipo string:

	>>> str(32)
	’32’

	>>> str(3.14149)
	’3.14149’


	|| COERCIÓN DE TIPOS

Ejemplo: calcular qué fracción de una hora habı́a transcurrido.

división de enteros: 
	es una operación que divide un entero entre otro y de-
	vuelve un entero. La división de enteros devuelve sólo el número entero
	de veces que el numerador es divisible por un denominador, y descarta el
	resto.

minuto / 60, realiza una división de enteros, por lo que el resultado
es siempre 0, incluso 59 minutos después de la hora.

alternativa es convetir minuto a tipo float (coma flotante) y luego efectuar
una división de coma flotante:

	>>> minuto = 59
	>>> float(minuto) / 60.0
	0.983333333333

O usamos la CONVERSION AUTOMATICA DE TIPOS, llamada COERCIÓN DE TIPOS:
	
	si uno de los operandos matemáticos es tipo float, el otro se convierte automáticamente
	en float.

		>>> minuto = 59
		>>> minuto / 60.0
		0.983333333333

Al usar un denomidador que es float, obligamos a Python a hacer división de
coma flotante.
	

	|| FUNCIONES MATEMÁTICAS

como sin (seno) y log, y que haya aprendido a evaluar expresiones como sin(pi/2) Y log(1/x).

Primero evalúa la expresión entre paréntesis, (el argumento).
	pi/2 = 1.571
	1/x es 0.1 (si x es igual a 10.0)

Luego evalúa la función en sı́ misma con tabla o calculos
	sin (seno) de 1.571 = 1
	log de 0.1 =  -1      // suponiendo log base 10

expresiones más complicadas como log(1/sin(pi/2)):
	Primero evaluamos el argumento de la funión más interna, luego se evalúa la función, y ası́ sucesivamente.

En python se aplica el módulo matemático:

	tenemos que importarlo:
		>>>import math

	tenemos que especificar el nombre del módulo (math)
	y el nombre de la función, separados por un punto.

Ej: 
	decibelio = math.log10 (17.0)
	angulo = 1.5
	altura = math.sin(angulo)

	La primera sentencia da a decibelio el valor del logaritmo de 17, en base 10.
	La tercera sentencia halla el seno del valor de la variable angulo. sin

las otras funciones trigonométricas (cos, tan, etc.) toman sus argumentos en radianes.
Para convertir de grados a radianes, puede dividir por 360 y multiplicar por
2*pi.

ejemplo, para hallar el seno de 45 grados, calcule primero el ángulo
en radianes y luego halle el seno:

	grados = 45
	angulo = grados * 2 * math.pi / 360.0
	math.sin(angulo)

La constante pi también es parte del módulo math por eso hay que llamar al módulo.

verificar el resultado comparándolo con el de la raı́z cuadrada de 2, dividida entre
2.
	>>> math.sqrt(2)
	0.707106781187

----------------------
En todos los calculos usamos la coerción de tipos
---------------------


	|| COMPOSICIÓN

usa una expresión como parte de otra.
usar cualquier expresión como argumento de una función:
	
	x = math.cos(angulo + pi/2)

toma el valor de pi, lo divide entre dos y le añade el resultado
al valor de angulo. La suma se pasa luego como argumento a la función cos.

	x = math.exp(math.log(10.0))

encuentra el logaritmo en base e de 10 y luego eleva e a ese
exponente. El resultado queda asignado a x.

	
	|| AÑADIR FUNCIONES NUEVAS

hemos usado las funciones que vienen incluidas con Python,
es posible añadir nuevas funciones.

La creación de nuevas funciones para resolver sus problemas particulares

en programación, función es una secuencia de instrucciones con
nombre, que lleva a cabo la operación deseada.

las instrucciones se hacen en la definicion de funciones.
	
	La sintaxis de la definición de una función es:	

		def NOMBRE( LISTA DE PARAMETROS ):
			SENTENCIAS

el nombre que desee para su función
lista de parámetros especifica qué información para usar en la función

Puede haber cualquier número de sentencias, deben estar identadas hacia adentro en el área de la func
NO hay que OLVIDARSE los dos puntos.

Una caracteristica de las funciones es que se pueden usar en cualquier momento. 
Además podemos evitar	tareas repetitivos usando nuestras funciones creadas.

	Funciones sin parametros:

		1| funcion que nos devuelve una línea nueva vacia:
				
				def nueva_linea():
				  print

		Contiene una única sentencia, que muestra como salida un carácter de nueva lı́nea (print sin argumentos)

		Llamamos a la funcion por su nombre incluido los parametros vacios:
				
				print "Primera linea."
				nueva_linea()
				print "Segunda linea."
		
		Entre medio vemos que hay una linea vacia entre los dos textos.

		Suponiendo que quisieramos más espacios, llamamos varias veces a la misma funcion 
				
				print "Primera linea."
				nueva_linea()
				nueva_linea()
				nueva_linea()
				print "Segunda linea."
		
		O escribimos una nueva funcion y adentro le ponemos nuestra primera función repetidas veces.
				
				def tresLineas():
				  nueva_linea()
				  nueva_linea()
				  nueva_linea()	

Motivos para crear funciones:
	
	Dar un nombre a un grupo de sentencias. ocultar cálculos complejos detrás de un nombre sencillo.
	
	Podemos hacer más pequeño el programa evitando código repetitivo. 
		
		Ej: primir nueve lı́neas consecutivas es llamar a nuestra funcion tresLineas() tres veces.


EJERCICIO: 
Escriba una función llamada nueveLineas que use 
tresLineas para imprimir nueve lı́neas en blanco. ¿Cómo imprimirı́a 27 lı́neas nuevas?
		
		def nueveLineas(9, tresLineas):
		   print(9*tresLineas)
		
		o
		
		def nueveLineas(tresLineas):
		  print(tresLineas*tresLineas*tresLineas)


ACTIVIDAD:

	def nueva_linea():
	  print

	def tresLineas():
	  nueva_linea()
	  nueva_linea()
	  nueva_linea()
	
	print "Primera Linea."
	tresLineas()
	print "Segunda Linea."

contiene dos definiciones de funciones: nueva linea y
tresLineas. Las sentencias del interior de
la función no se ejecutan hasta que se llama a la función, y la definición de la
función no genera salida.

	Como actividad, pruebe a ejecutar este programa moviendo las tres
	últimas sentencias al principio del programa. Registre qué mensaje
	de error obtiene usted.

	Como segunda actividad, pruebe a tomar la versión del programa
	que funcionaba y a mover la definción de nueva linea más abajo
	que la definición de tresLineas . ¿Qué ocurre cuando ejecuta el
	programa?


	|| FLUJO DE EJECUCIÓN

orden en el que se ejecutan las sentencias
para asegurarse de que una función se define antes de su primer uso.

comienza siempre por la primera sentencia del programa.
Las sentencias se ejecutan a razón de una cada vez, en orden, hasta que se alcanza una
llamada a una función.
funciones no alteran el flujo de ejecución del programa, pero sus sentencias no se ejecutan hasta
que se llame a la funcion.

Podemos DEFINIR o crear una función dentro de otra, pero no es habitual.
La función interior no se ejecuta hasta que no se llama a la función exterior.

Las llamadas a funciones son como un desvı́o en el flujo de ejecución. En lugar
de ir a la siguiente sentencia, el flujo salta hasta la primera lı́nea de la función
a la que se llama, ejecuta todas las sentencias que encuentre allı́, y vuelve a
retomar la ejecución en el punto donde lo dejó.

una función puede llamar a otra. Mientras estamos en medio de una función, podrı́amos vernos
obligados a abandonarla e ir a ejecutar sentencias en otra función más. Pero
mientras estamos en esta nueva función, ¡podrı́amos salirnos y ejecutar otra
función más!

cada vez que se completa una función, el programa retoma el punto en donde
lo dejó en la función que hizo la llamada. Cuando llega al final del programa,
termina.
	
	ENTONCES, CUANDO LEEMOS UN PROGRAMA LO HACEMOS TENIENDO EN CUENTA EL FLUJO DE EJECUCIÓN
	no desde arriba hacia abajo.

	
	|| PARÁMETROS Y ARGUMENTOS

Las funciones internas o nativas de python precisan de ARGUMENTOS: 
valores que controlan cómo la función lleva a cabo su tarea

	EJ: math.sin(x valor)   #numerico

algunas toman más de un argumento.

Dentro de la función, los valores que se le han
pasado se asignan a variables llamadas PARÁMETROS.

	Función con un parámetro: 
		
		def imprimeDoble(paso):
		  print paso, paso
	
	toma un único argumento y se lo asigna a un parámetro llamado paso.

	El valor del parámetro (en este punto todavı́a no tenemos ni idea de cuál será) se imprime dos veces
	elija un nombre más ilustrativo que paso.

---------------
	EL PARAMETRO SOLO ES EL NOMBRE de la variable, el valor de adentro puede ser cualquiera.
	
		ej: fun1(numero)
                 numero + 2		        
	En la llamada le pasamos el valor para que se guarde en la variable/parametro y con eso aplica las sentencias.
---------------

	La funcion imprimeDoble sirve con cualquier tipo (de dato) que se pueda imprimir:
	
	>>> imprimeDoble(’Jamón’)
	Jamón Jamón

	>>> imprimeDoble(5)
	5 5

	>>> imprimeDoble(3.14159)
	3.14159 3.14159

Podemos aplicar REGLAS DE COMPOSICIÓN:
	
	usar cualquier tipo de expresión como argumento
		
		>>> imprimeDoble(’Jamón’*4)
		JamónJamónJamónJamón JamónJamónJamónJamón

		>>> imprimeDoble(math.cos(math.pi))
		-1.0 -1.0

USAR VARIABLE COMO ARGUMENTO:
	
	>>> latoya = ’Dafne, es mitad laurel mitad ninfa’

	>>> imprimeDoble(latoya)
	  Dafne, es mitad laurel mitad ninfa. Dafne, es mitad laurel mitad ninfa.

Imprime dos veces el contenido de la variable.

*la variable latoya como argumento no tiene nada que ver con el parametro paso definido en la funcion.


	|| LAS VARIABLES Y LOS ARGUMENTOS SON LOCALES





	|| RECAPITULANDO: FUNCIONES

	Parámetros:
		Valores que especificamos en la funcion que definimos.
		Es una variable que representa y guarda los valores que le pasamos cuando llamamos a la funcion
		(el primer paso de una funcion es la definicion o la tarea que va a ejecutar y el segundo es la llamada
		que es la ejecución con distintos valores o argumentos.)
		Si no indicamos o necesitamos parámetros no le podemos pasar valores en la llamada o ejecución.
		Puede ser usado en el cuerpo de la función para después, en la llamada, darle un valor como a cualqueir variable (nombreVar = valor)
		
			Argumentos:
				Valor que le asignamos a un parámetro cuando llamamos a la función.
		
			Ej: 
				def mostrar_doble (num):		def sumar (num1, num2):
					print (num * 2)					print (num1 + num2)

llamada:		mostrar_doble(4)				sumar(2, 4)
Respuesta:		8								6		
			
			
			Return:
				Valor-respuesta de una funcion que puede ser guardado en una variable.
				Cuando se ejecuta la sentencia return, la función se detiene inmediatamente.
				Si no definimos return, el valor de retorno es NONE; que se usa para representar 
				casos donde no hay valor especifico asignado. No podríamos usar la respuesta de la llamada
				como variable porque no guarda valor.
			
			Ej:                                                                                  Ej: valor de retorno none
				def sumar (x, y):							print (resultado)
					return x + y
				
				resultado = sumar (2, 2)
				4


		|| PYTHON 2 VS PYTHON 3
			
		             P3                                                             vs                                                                   P2
					
print:		print('Hola, mundo')												print 'Hola, mundo'



		|| Errores 

>>> print ("hola, mundo)
  File "<stdin>", line 1
    print ("hola, mundo)
                                             ^			// marca dónde está el error sintáctico. 
SyntaxError: EOL while scanning string literal


>>> 011                                                                        
  File "<stdin>", line 1
    011
      ^
SyntaxError: invalid token


>>> print ("hola, mundo)
  File "<stdin>", line 1
    print ("hola, mundo)
                       ^
SyntaxError: EOL while scanning string literal:

En Python 3, los ceros iniciales no están permitidos en los números. P.ej:

05
0123

Etc. no están permitidos, pero deben escribirse como 5 y 123 en su lugar.

Sin embargo, en Python 2, el cero inicial significa que el número es un número octal (base ocho), por lo que 04 o 03 significarían 4 y 3 en octal, respectivamente, pero 08 no sería válido porque no es un número octal válido.

En Python 3, la sintaxis de octales cambió a esto:

0o10
0o4

(Además de permitir otras bases como binarias y hexadecimales usando los prefijos 0b o 0x).

En cuanto a su otra pregunta, un token en Python es la forma en que el intérprete de Python divide su código en partes, para que pueda entenderlo (ver aquí). Aquí, cuando el tokenizador intenta dividir su código, no espera ver el cero allí y, por lo tanto, arroja un error.

Sugeriría (de manera similar a las otras respuestas) que suelte el cero inicial ((2016,4,3)) o los represente usando cadenas ("2016","04","03")).

	
	|| Ejercicio funciones

	#prompt

def hola_mundo():
	print ("hola, mundo!")

print ("he definido y he salido de la función")

hola_mundo()

print("he llamado a la función")
	
	#interprete		

he definido y he salido de la función
hola, mundo!
he llamado a la función
>>> 

	Preguntas:

1. ¿Qué sucede si llama usted a una función y no hace nada con el resultado

(es decir, no lo asigna a una variable ni lo usa como parte de una expresión
más amplia)?

	---
	type()
	Traceback (most recent call last):
	TypeError: type() takes 1 or 3 arguments

	print()

	---
	def error_sint(num1, num2):
	 num1 + num2

	error_sint(2, 1)
	<function error_sint at 0xb775865c>

	O

	def error_sint(num1, num2):
	 num1 + num2

	error_sint(2, 1)

	print (error_sint(2, 1))
	None

	*no guarde la expresión en var ni la pase a una func.
	pero lanza dos errores distintos.
	---
	def error_sint(num1, num2):
	calcu = num1 + num2

	error_sint(2, 1) 

	print (error_sint)
	*cree una var local, llame e imprimi a la func, no a la var.

	O

	def error_sint(num1, num2):
	calcu = num1 + num2

	error_sint(2, 1)

	print (calcu) 
	*llame func, despues imprimi var

	Traceback (most recent call last):
	NameError: name 'calcu' is not defined,

	---
	def error_sint(num1, num2):
	print(num1 + num2)

	error_sint(1, 2)
	3
	*ejecuta correctamente.

2. ¿Qué sucede si usa una función sin resultado como parte de una expresión,
por ejemplo nueva linea() + 7?

	TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

