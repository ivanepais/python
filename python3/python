// ANOTACIONES

|| PSEUDOCÓDIGO:

	Pensar como se crea o puede llegar a crear cada objeto.

	Las instrucciones (comandos, órdenes) basicas:
	
	entrada:

		Recibir datos del teclado, o un archivo u otro aparato.

	salida:

		Mostrar datos en el monitor o enviar datos a un archivo u otro aparato.

	matemáticas:

	 	Operaciones básicas de matemáticas como la adición y la multiplicación.

	operación condicional:

		Probar la veracidad de alguna condición y ejecutar una secuencia de instrucciones apropiada.

	repetición: 

		Ejecutar alguna acción repetidas veces, normalmente con alguna variación.


|| CREAR FUNCIONES:

	encapsular: 

		Meter el código que crea los objetos en las definiciones de función.


	generalizar:

		Crear variables genericas  en el cuerpo de la función, sin valores determinados para pasarles valores en la llamada.

		Así los objetos son diferentes en dimensiones, formas, aspecto, etc.


	diseño de interfaz:

		Explica como se utiliza la función: 

			¿cuáles son los parámetros? 

			¿Qué hace la función? 

			¿Y cuál es el valor de retorno? 

		Una interfaz es “limpia” si permite a la sentencia llamadora hacer lo que quiere sin lidiar con detalles innecesarios.		

	refactorización:

		Reorganizar un programa para mejorar las interfaces y facilitar la reutilización de código. 


	depuración:

		Corregir errores es programar.


			hipótesis:

				Con una hipostesis correcta podemos predecir comportamientos para modificar el programa y llegar a un resultado correcto o esperado.

				Hay que leer el código, entender cada línea para corregir los errores.


			flujo de ejecución:

				sentencias/def función > sentencias > llamada función (<< sentenc función) > sentencias.

				*leer flujo, no de inicio a fin.


|| PLAN DE DESARROLLO

	un proceso para escribir programas.

		Ej: “encapsulamiento y generalización”.

		1. Comenzar escribiendo un programa pequeño sin definiciones de función.

		2. Una vez que el programa funciona, identifica una parte coherente, encapsula la parte en una función y dale un nombre.

		3. Generaliza la función agregando parámetros apropiados.
	
		4. Repite los pasos 1–3 hasta que tengas un conjunto de funciones eficaces. Copia y pega código que funcione para evitar repetir (y volver a depurar).

		5. Busca oportunidades para mejorar el programa refactorizando. Por ejemplo, si tienes código similar en muchos lugares, considera factorizarlo dentro de una función
		general apropiada.


|| TÉCNICAS
	
	Paso a paso:

		Escribir las ideas que vamos aplicar en cada línea de código, paso a paso; antes de escribir una variable, función, etc.

		Esto nos dará una idea general sobre como empezar el programa.

		Dividir el programa en muchas funciones, cada una debería hacer una sola cosa.


	Abtraer problemas:

		Leer y pensar en el problema, sin programar.

		Hacer pruebas son entradas simples que nos de una salida esperada.

		Buscar patrones, escribir el algoritmo a alto nivel.

		Ir iterando cada vez más a bajo nivel.

		Una vez con la solución, encontrar cosas para mejorar, patrones para abstraer; herramientas del lenguaje que nos ayuden.

		No hay una sola posible solución, primero hacemos que funciones, despues lo hacemos legible.


	Autoevaluación:

		Cosas que no entendemos, Por qué es?, Qué conceptos están en juego? Que no los tenemos claro.

		Probar otras cosas y ver las consecuencias. Fallas en el razonamiento, Cuales? Por qué?

		Entender el tema, las operaciones, los pasos a seguir y ejecutarlos.


	Implementación avanzada:

		A veces resolvemos un problema pero que para un nivel inicial.

		Pero podemos usar conceptos avanzados: estructuras de control correctas, que el código sea eficiente (complejidad, orden de ejecución), código limpio, legible, modular, estructuras de datos.



|| BUENAS PRACTICAS:
	
	Escribir las variables, const, func y documentar en inglés.

	Crear formulas en variables para pasarselas a las funciones, metodos nativos o creadas, etc.

	import math, al inicio del programa.