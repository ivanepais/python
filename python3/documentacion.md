# Documentación de Python

|| PYTHON
	
	Fue creado a finales de los años 80 y principios de los 90 por Guido van Rossum, un programador holandés. 

	Su objetivo principal era desarrollar un lenguaje de programación que fuera fácil de leer, escribir y comprender.

	Van Rossum quería un lenguaje que promoviera una sintaxis clara y un enfoque práctico en lugar de ser excesivamente complejo. 

	Python tomó inspiración de lenguajes como ABC, Modula-3 y otros.


	Propósito:

		El propósito principal de Python era ser un lenguaje general de propósito que pudiera ser utilizado para una amplia gama de aplicaciones, desde desarrollo web hasta scripting, análisis de datos, automatización, inteligencia artificial y más.

		Python se centró en la legibilidad y la facilidad de uso, lo que lo hace especialmente adecuado para principiantes y programadores experimentados por igual.

		Además de su legibilidad, Python también promueve la filosofía de "baterías incluidas", lo que significa que viene con una amplia biblioteca estándar que proporciona módulos y funciones para muchas tareas comunes, lo que simplifica el desarrollo.

		
	Actualidad:

		Hoy en día, Python es uno de los lenguajes de programación más populares y ampliamente utilizados en todo el mundo.

		Ha ganado una gran adopción en diversos campos debido a su versatilidad y facilidad de uso. Algunos de los usos más destacados de Python incluyen:


    Desarrollo Web: 

    	Python se utiliza en el desarrollo de aplicaciones web a través de frameworks como Django y Flask, que facilitan la creación de aplicaciones robustas y escalables.


    Ciencia de Datos y Análisis: 

    	Python es muy popular en la comunidad de ciencia de datos debido a bibliotecas como NumPy, pandas, Matplotlib y scikit-learn, que facilitan el análisis y la visualización de datos.


    Inteligencia Artificial y Aprendizaje Automático: 

    	Python es un lenguaje preferido para la implementación de algoritmos de aprendizaje automático e inteligencia artificial debido a bibliotecas como TensorFlow y PyTorch.


    Automatización y Scripting: 

    	Python es ampliamente utilizado para la automatización de tareas y la creación de scripts debido a su legibilidad y facilidad de uso.


    Aplicaciones Científicas y de Ingeniería: 

    	Python se utiliza en aplicaciones científicas y de ingeniería, como simulaciones, modelado numérico y más.


	Python continúa evolucionando con nuevas versiones y mejoras. 

	La comunidad de Python es activa y contribuye con paquetes y bibliotecas de código abierto para abordar una amplia variedad de problemas y aplicaciones. 



|| CARACTERÍSTICAS

	Es un lenguaje de programación de alto nivel, interpretado y de propósito general. 

	Fue diseñado para ser legible y fácil de entender, lo que lo hace adecuado tanto para principiantes como para programadores experimentados. 

	Python se destaca por su sintaxis clara y su enfoque en la legibilidad del código, lo que facilita la escritura y el mantenimiento de programas.


    Sintaxis clara: 

    	Python se enorgullece de tener una sintaxis simple y fácil de leer, lo que facilita la comprensión del código incluso para aquellos que son nuevos en la programación.


    Tipado dinámico: 

    	No necesitas declarar el tipo de variable antes de usarla. 

    	Python infiere automáticamente el tipo de datos basándose en el valor asignado.


    Interpretado: 

    	Python es un lenguaje interpretado, lo que significa que no es necesario compilar el código antes de ejecutarlo. 

    	El intérprete de Python traduce el código línea por línea en tiempo real.


    Multiplataforma: 

    	Puedes escribir y ejecutar código Python en varias plataformas, como Windows, macOS y Linux, sin preocuparte por cambios significativos en el código.


    Amplia biblioteca estándar: 

    	Python viene con una gran biblioteca estándar que ofrece una amplia gama de módulos y funciones que facilitan tareas comunes, desde manipulación de cadenas hasta acceso a redes y manejo de archivos.



|| FUNCIONAMIENTO

    Escritura del código: 

    	Los programadores escriben el código fuente de sus programas en archivos con extensión .py. 

    	Estos archivos contienen instrucciones escritas en el lenguaje Python.


    Interpretación: 

    	Cuando ejecutas un archivo .py, el intérprete de Python procesa el código línea por línea y ejecuta las instrucciones. 

    	No es necesario compilar el código en un archivo ejecutable separado.


    Creación de objetos: 

    	Python es un lenguaje orientado a objetos. 

    	Los datos y las funcionalidades se organizan en objetos y clases. 

    	Los objetos son instancias de clases que contienen atributos y métodos.


    Gestión de memoria: 

    	Python administra automáticamente la asignación y liberación de memoria para objetos. 

    	Utiliza un mecanismo llamado "recolección de basura" para liberar la memoria de objetos que ya no son necesarios.


    Interacción con el sistema: 

    	Python puede interactuar con el sistema operativo, acceder a archivos, redes y recursos externos a través de módulos incorporados o de terceros.


    Ejecución de scripts: 

    	Además de ejecutar programas en la consola interactiva de Python, también puedes crear scripts que se ejecutan como programas independientes desde la línea de comandos.


    Importación de módulos: 

    	Python facilita la reutilización de código al permitir la importación de módulos y bibliotecas predefinidos o creados por los usuarios.


    Depuración y pruebas: 

    	Python ofrece herramientas para depurar y probar el código, como la función print() para imprimir valores y herramientas más avanzadas para rastrear errores.


	En resumen, Python es un lenguaje de programación versátil y potente que se destaca por su legibilidad y facilidad de uso. 

	Su enfoque en la simplicidad y su amplia gama de aplicaciones lo convierten en una herramienta valiosa para una variedad de proyectos, desde desarrollo web hasta análisis de datos y más.




|| VERSIONES  

	Cada versión de Python trae consigo nuevas funcionalidades, mejoras de rendimiento y correcciones de errores. 

	Es fundamental mantenerse actualizado con las versiones más recientes para aprovechar las ventajas de seguridad y funcionalidad que ofrece el lenguaje.


	Python 1.x: 

		Las primeras versiones de Python, como 1.0 y 1.5, se lanzaron en la década de 1990. 

		Estas versiones iniciales establecieron los fundamentos del lenguaje y establecieron la base para su desarrollo futuro.


    Python 2.x: 

    	Esta serie incluye versiones como 2.0, 2.7, etc. Python 2.x fue ampliamente utilizado y popular durante muchos años. 

    	Sin embargo, en 2008, se anunció que Python 2.x dejaría de recibir soporte oficial después del 2020. 

    	La transición de Python 2.x a Python 3.x tomó tiempo debido a algunas diferencias significativas entre las dos versiones.


    Python 3.x: 

    	Lanzado por primera vez en 2008, Python 3.x introdujo mejoras significativas en el lenguaje. 

    	Se eliminaron algunas características obsoletas y se realizaron cambios para hacer el lenguaje más coherente y más fácil de entender. 

    	Python 3.x se diseñó con la idea de ser más limpio, más eficiente y más orientado al futuro. 

    	La versión más reciente en esta serie es Python 3.9.


    Python 3.10: 

    	A medida que Python continúa evolucionando, nuevas versiones se lanzan periódicamente con mejoras y nuevas características.

    	Python 3.10 es una versión más reciente que sigue mejorando y refinando el lenguaje.


	Es importante tener en cuenta que, con el fin del soporte para Python 2.x, se recomienda encarecidamente usar Python 3.x para cualquier proyecto nuevo. 

	La comunidad y los desarrolladores han migrado en gran medida a Python 3.x debido a sus mejoras y la falta de soporte para nuevas versiones de Python 2.x.


	Funcionalidades agregadas: 

		Python 3.0 (2008):

		    Introducción de la división de enteros por defecto. 

		    En Python 2.x, la división de enteros generaba otro entero.

		    En Python 3.x, la división de enteros genera un número de punto flotante por defecto.

		    Eliminación de algunas características obsoletas.

		    Mejora en la manipulación de cadenas y Unicode.

		    Introducción de funciones generadoras y expresiones generadoras.

		    Cambios en la impresión de cadenas (se introdujo la función print() con paréntesis).

		    Nueva sintaxis para el manejo de excepciones.


		Python 3.1 (2009):

		    Mejoras en la velocidad y optimización del intérprete.

		    Agregación de nuevos módulos y bibliotecas.

		    Mejoras en el manejo de excepciones.

		    Nueva sintaxis para decoradores.


		Python 3.2 (2011):

		    Mejoras en la biblioteca estándar.

		    Introducción de la función 'functools.lru_cache()' para cachear resultados de funciones.

		    Introducción de la sintaxis 'with' para la gestión de contextos.


		Python 3.3 (2012):

		    Introducción de la sintaxis 'yield from' para simplificar el uso de generadores anidados.

		    Agregación del módulo 'venv' para la creación de entornos virtuales.

		    Mejoras en el rendimiento y la eficiencia.

		    Nuevas características en la biblioteca estándar.


		Python 3.4 (2014):

		    Introducción del módulo 'asyncio' para programación asíncrona.

		    Incorporación del decorador '@asyncio.coroutine' para definir generadores asincrónicos.

		    Adición de un nuevo operador de matriz '@' para multiplicación de matrices.

		    Mejoras en la biblioteca estándar y correcciones de errores.


		Python 3.5 (2015):

		    Introducción de la palabra clave 'await' para la programación asincrónica.

		    Adición de la expresión 'async def'para definir funciones asincrónicas.

		    Incorporación de la biblioteca typing para anotaciones de tipos.

		    Mejoras en la sintaxis y rendimiento.


		Python 3.6 (2016):

		    Introducción del operador de formateo de cadenas 'f-strings'.

		    Adición de la biblioteca 'secrets' para la generación segura de números aleatorios y tokens.

		    Introducción de la anotación de tipos en funciones y variables.

		    Agregación del operador de desempaquetado '**' en expresiones.


		Python 3.7 (2018):

		    Introducción de operadores matriciales '@' para multiplicación de matrices y productos escalares.

		    Incorporación del método '__annotations__' para acceder a las anotaciones de tipos.

		    Adición del módulo 'dataclasses' para la creación simplificada de clases de datos.

		    Mejoras en el rendimiento y optimización del intérprete.


		Python 3.8 (2019):

		    Introducción de las expresiones de asignación (:=).

		    Agregación de la característica de "walrus operator" (:=) para asignar y evaluar expresiones en una sola línea.

		    Incorporación del módulo 'math.isqrt()' para cálculos de raíces cuadradas enteras.

		    Mejoras en la sintaxis y la eficiencia.


		Python 3.9 (2020):

		    Introducción de operadores '|' y '|=' para realizar operaciones de unión en diccionarios.

		    Incorporación del operador '|' para realizar operaciones de unión en conjuntos.

		    Agregación de la sintaxis '|=' para actualizar conjuntos y diccionarios.

		    Mejoras en el rendimiento y nuevas características en la biblioteca estándar.



|| BIBLIOTECA ESTÁNDAR
	
	Es una parte esencial del lenguaje y juega un papel fundamental en su versatilidad y utilidad. 


	Origen de la Biblioteca Estándar:

		La biblioteca estándar de Python se ha desarrollado y evolucionado a lo largo de los años desde que Python fue creado por Guido van Rossum en la década de 1980.

		Desde sus primeras versiones, Python ha incluido una colección de módulos y bibliotecas que proporcionan una amplia variedad de funcionalidades útiles.


	Propósito de la Biblioteca Estándar:

		El propósito principal de la biblioteca estándar de Python es proporcionar un conjunto completo de módulos y bibliotecas que abarquen una amplia gama de tareas comunes de programación.


    	Facilitar el Desarrollo: 

    		Proporcionar un conjunto de herramientas que simplifiquen el desarrollo de aplicaciones en Python. 

    		Esto incluye módulos para entrada/salida, manipulación de archivos, redes, expresiones regulares, entre otros.


    	Promover las Mejores Prácticas: 

    		Incluir módulos que promuevan buenas prácticas de programación, como el módulo unittest para pruebas unitarias y el módulo logging para el registro de eventos.


    	Estándares y Portabilidad: 

    		Ofrecer una base común para que los desarrolladores escriban código Python que sea portátil y compatible con diferentes sistemas operativos y plataformas.


    	Eficiencia y Rendimiento: 

    		Proporcionar módulos que estén implementados de manera eficiente y optimizada para tareas comunes, como el módulo collections para estructuras de datos especializadas.


    	Soporte para Funcionalidades Avanzadas: 

    		Incluir módulos para tareas avanzadas, como manipulación de datos, matemáticas, criptografía, manejo de fecha y hora, y más.


	Actualidad de la Biblioteca Estándar:

		La biblioteca estándar de Python continúa siendo una parte vital del lenguaje y se mantiene activamente por la comunidad de desarrollo de Python. 

		Con cada nueva versión de Python, se realizan mejoras y se agregan nuevas características a la biblioteca estándar.

		Además, la comunidad de Python ha desarrollado y sigue manteniendo una amplia variedad de paquetes y bibliotecas de terceros que se basan en la biblioteca estándar y amplían sus capacidades. 

		Esto ha llevado a un ecosistema rico y diverso de herramientas disponibles para los desarrolladores de Python.


	En resumen, la biblioteca estándar de Python tiene un origen histórico y un propósito claro de proporcionar un conjunto completo de módulos y herramientas para el desarrollo de aplicaciones en Python. 

	Continúa siendo una parte vital y actualizada del lenguaje Python, facilitando la programación en una amplia gama de aplicaciones y escenarios.


	Módulos de Manejo de Datos:

       	os: 

       		Interacción con el sistema operativo.


        sys: 

        	Funciones y variables relacionadas con el intérprete de Python.


        io: 

        	Entrada y salida de datos.
        

        json: 

        	Serialización y deserialización de JSON.


        csv: 

        	Lectura y escritura de archivos CSV.


        pickle: 

        	Serialización de objetos Python.


        sqlite3: 

        	Interacción con bases de datos SQLite.


    Módulos de Procesamiento de Texto y Cadenas:

        re: 

        	Expresiones regulares.


        string: 

        	Operaciones y constantes relacionadas con cadenas.


        textwrap: 

        	Formateo de texto con saltos de línea y relleno.


        codecs: 

        	Codificación y decodificación de texto.


    Módulos de Fecha y Hora:

        datetime: 

        	Manipulación de fechas y horas.


        time: 

        	Funciones de tiempo.


        calendar: 

        	Funciones relacionadas con calendarios.


    Módulos de Matemáticas:

        math: 

        	Funciones y constantes matemáticas.


        random: 

        	Generación de números aleatorios.


        statistics: 

        	Estadísticas básicas.


    Módulos de Estructuras de Datos:

        collections: 

        	Tipos de datos especializados como deque y Counter.


        heapq: 

        	Algoritmos de colas de prioridad.


        array: 

        	Arreglos de tipo numérico.


    Módulos de Procesamiento de Archivos:
        
        pathlib: 

        	Manipulación de rutas de archivos y directorios.

        fileinput: 

        	Lectura de múltiples archivos de entrada.


    Módulos de Red y Comunicación:
        
        socket: 

        	Comunicación de red.

        http.server: 

        	Servidor HTTP incorporado.

        smtplib: 

        	Envío de correos electrónicos.

        urllib: 

        	Interacción con URLs.


    Módulos de Interfaz de Usuario:
       
        tkinter: 

        	Biblioteca gráfica para interfaces de usuario.
        	
        	curses: Interfaz de texto para terminales.


    Módulos de Pruebas y Depuración:
        
        unittest: 

        	Marco de pruebas unitarias.


        pdb: 

        	Depurador interactivo.


        trace: 

        	Tracing de código.


        doctest: 

        	Pruebas basadas en docstrings.


    Módulos de Criptografía y Seguridad:
        
        hashlib: 

        	Funciones de resumen (hashing).


        cryptography: 

        	Biblioteca criptográfica avanzada.



|| EJECUTAR O CORRER PYTHON 
	
	1. Ejecución Interactiva:

		Python ofrece un intérprete interactivo que te permite ejecutar comandos y ver los resultados inmediatamente. 

		Puedes abrir el intérprete interactivo de Python escribiendo "python" en la línea de comandos (en sistemas Unix/Linux) o "python" en el símbolo del sistema (en Windows). 

		Luego, verás el indicador >>>, lo que significa que puedes comenzar a escribir código Python y ver los resultados de inmediato.

		```
			$ python
			Python 3.9.6 (default, Jun 29 2021, 06:20:32)
			[GCC 8.4.0] on linux
			Type "help", "copyright", "credits" or "license" for more information.
			>>>

		```

		Para salir del intérprete, puedes escribir exit() o presionar Ctrl + D (en sistemas Unix/Linux) o Ctrl + Z (en Windows).


	2. Ejecución de Archivos:
		
		Para ejecutar programas Python almacenados en archivos, sigue estos pasos:

    	Crea un archivo con extensión .py usando un editor de texto. 

    	Por ejemplo, puedes usar Notepad en Windows o cualquier editor de texto en otros sistemas.
    
    	Escribe el código Python en el archivo. Por ejemplo, puedes escribir:

    	```python

    		print("Hola, mundo")

    	```

    	Guarda el archivo con un nombre descriptivo y la extensión .py, por ejemplo, mi_programa.py.

	    Abre una ventana del símbolo del sistema (Windows) o terminal (Unix/Linux).

	    Navega al directorio donde guardaste el archivo .py usando el comando cd.

	    Ejecuta el archivo usando el comando python nombre_del_archivo.py. Por ejemplo:

	    ```python

	    	$ python mi_programa.py
			Hola, mundo

	    ```


	3. Ejecución en un entorno de programación:

		Puedes correr Python instalandolo según la forma correspondiente para cada entorno de programación, como pueden ser Visual Studio Code, Sublime y otros parecidos. 



|| SINTAXIS

	
	Comentarios:
		
		Son líneas de texto que se utilizan para agregar explicaciones o notas en el código. 

		En Python, los comentarios comienzan con el símbolo #. 

		Todo lo que sigue a # en la misma línea es considerado un comentario y no se ejecutará.

		```python

			# Esto es un comentario
			print("Hola, mundo")  # Esto también es un comentario

		```


	Indentación:
			
		Python utiliza la indentación (espacios o tabulaciones) para delimitar bloques de código en lugar de utilizar llaves o palabras clave. 

		Los bloques de código deben tener la misma cantidad de indentación.

		```python

			if True:
				print("Este está indentado correctamente")
				print("Este también")

			print("Este no está indentado correctamente")  # Generará un error

		```


	Variables y Asignación:
		
		En Python, puedes asignar valores a variables utilizando el operador =. 

		No es necesario declarar el tipo de variable.

		````python

			mensaje = "Hola, Python"
			numero = 42
			decimal = 3.14

		```


	Tipos de Datos:
		
		Python tiene varios tipos de datos incorporados, como cadenas (str), números enteros (int), números de punto flotante (float), listas (list), tuplas (tuple), conjuntos (set), diccionarios (dict) y más.

		```python

			cadena = "Hola, Python"
			entero = 42
			decimal = 3.14
			lista = [1, 2, 3]
			tupla = (4, 5, 6)
			conjunto = {7, 8, 9}
			diccionario = {"clave": "valor"}

		```


	Entrada y Salida:
		
		Puedes usar la función input() para recibir datos del usuario y la función print() para mostrar información en la pantalla.

		```python

			nombre = input("Ingresa tu nombre: ")
			print("Hola,", nombre)

		```


	Estructuras de Control:

		Python utiliza las estructuras de control if, elif y else para tomar decisiones, y bucles for y while para realizar iteraciones.

		```python

			if edad < 18:
			    print("Eres menor de edad")
			elif edad >= 18:
			    print("Eres mayor de edad")
			else:
			    print("Edad desconocida")

			for i in range(5):
			    print(i)

			while contador < 10:
			    print(contador)
			    contador += 1

		```



|| VARIABLES 

	Son contenedores utilizados para almacenar valores en Python.


	Declaración y Asignación:
		
		En Python, no es necesario declarar explícitamente el tipo de variable antes de usarla.

		Simplemente asigna un valor a una variable utilizando el operador de asignación '='.

		```python

			nombre = "Alice"  # Asigna una cadena a la variable "nombre"
			
			edad = 25  # Asigna un número entero a la variable "edad"
			
			altura = 1.75  # Asigna un número de punto flotante a la variable "altura"

		```


	Nombres de Variables:
		
		Los nombres de variables en Python deben seguir ciertas reglas:

			Deben comenzar con una letra (mayúscula o minúscula) o con un guión bajo (_).

			Pueden contener letras, números y guiones bajos.

			Los nombres distinguen entre mayúsculas y minúsculas (por ejemplo, nombre y Nombre son diferentes).

			```python

				nombre = "Alice"  # Correcto
				Nombre = "Bob"  # Correcto, pero distinto de "nombre"
				_ultimo_nombre = "Smith"  # Correcto
				1edad = 25  # Incorrecto, no puede comenzar con un número

			```


	Tipos de Variables:
		
		Las variables en Python pueden contener diferentes tipos de valores, como cadenas, números enteros, números de punto flotante, listas, etc.

		```python

			nombre = "Alice"  # Cadena
			edad = 25  # Entero
			altura = 1.75  # Punto flotante
			numeros = [1, 2, 3, 4]  # Lista

		```


	Reasignación:
		
		Puedes cambiar el valor de una variable en cualquier momento reasignándole un nuevo valor.

		```python

			edad = 25
			print(edad)  # Imprimirá 25

			edad = 30
			print(edad)  # Imprimirá 30

		```


	Operaciones con Variables:
		
		Puedes realizar operaciones matemáticas y manipulaciones con variables.

		```python

			x = 5
			y = 3
			suma = x + y  # Suma de variables
			producto = x * y  # Multiplicación de variables

			nombre = "Alice"
			saludo = "Hola, " + nombre  # Concatenación de cadenas

		```

	Convenciones de Nombres:
		
		Se recomienda seguir convenciones de nombres para hacer el código más legible:

    		Utiliza nombres en minúsculas para las variables (nombre, edad).
    	
    		Si el nombre consta de varias palabras, sepáralas con guiones bajos (nombre_completo, puntos_totales).

    		Evita nombres que puedan confundirse con palabras clave de Python (if, while, etc.).	


    Alcance de Variables:
		
		El alcance de una variable es la parte del programa donde esa variable es visible y puede ser utilizada. 

		Las variables pueden tener alcance global (en todo el programa) o alcance local (limitado a una función o bloque).

		```python

			variable_global = 10  # Variable global

			def mi_funcion():
			    variable_local = 5  # Variable local
			    print(variable_global)  # Puedo acceder a una variable global aquí

			print(variable_global)  # Puedo acceder a una variable global aquí
			print(variable_local)  # Esto generará un error, la variable local no es visible aquí

		```



|| TIPOS DE DATOS
	
	Los tipos de datos en Python definen el tipo de valor que una variable puede contener. 

	Python tiene varios tipos de datos incorporados, cada uno con sus propias características y operaciones.
	

	Cadena (str):
		
		Las cadenas son secuencias de caracteres. 

		Pueden contener letras, números, símbolos y espacios. Las cadenas se crean utilizando comillas simples ('...') o comillas dobles ("...").

		```python

			nombre = "Alice"
			mensaje = 'Hola, ¿cómo estás?'

		```


		Inmutabilidad: 

			Las cadenas son inmutables, lo que significa que no puedes modificar sus caracteres directamente después de crearlas. Sin embargo, puedes crear nuevas cadenas basadas en las existentes.


		Longitud: 

			Puedes obtener la longitud de una cadena utilizando la función incorporada len().

			```python

				mensaje = "Hola, mundo"
			longitud = len(mensaje)  # Devuelve 11

				```


		Concatenación: 

			Puedes concatenar cadenas utilizando el operador +.

			```python

				saludo = "Hola, "
			nombre = "Alice"	
			mensaje = saludo + nombre  # Devuelve "Hola, Alice"

			```	


		Indexación y Segmentación:

			Puedes acceder a caracteres individuales de una cadena utilizando índices. 

			La indexación comienza desde 0.

			```python

				palabra = "Python"
			primer_caracter = palabra[0]  # Devuelve "P"

			```

			Puedes segmentar (cortar) cadenas para obtener subcadenas.

			```python

				mensaje = "Hola, mundo"	
			
			subcadena = mensaje[0:5]  # Devuelve "Hola,"

			```

   		Metodos: 
   			
   			.lower(): Convierte la cadena en minúsculas.

			.upper(): Convierte la cadena en mayúsculas.

			.strip(): Elimina espacios en blanco al principio y al final de la cadena.

			.split(): Divide la cadena en una lista de subcadenas usando un delimitador.

			.replace(): Reemplaza una subcadena con otra.

			```python

				texto = "Hola, Mundo"
				texto_min = texto.lower()  # "hola, mundo"
				texto_may = texto.upper()  # "HOLA, MUNDO"

			```


		Formateo de Cadenas:	
		
			Puedes formatear cadenas utilizando literales de cadena f (f-strings) o el método .format().

			```python

				nombre = "Alice"
				edad = 30
				saludo = f"Hola, {nombre}. Tienes {edad} años."

			```

			```python

				nombre = "Alice"
				edad = 30
				saludo = "Hola, {}. Tienes {} años.".format(nombre, edad)

			```


		Comprobación de Contenido:
			
			Puedes verificar si una subcadena está presente en una cadena utilizando los operadores in y not in.

			```python

				mensaje = "Hola, mundo"
				
				if "mundo" in mensaje:
				    print("La subcadena 'mundo' está presente.")

			```


	Números (int y float):
		
		Los números en Python pueden ser enteros (int) o de punto flotante (float).		

		```python

			entero = 42
			decimal = 3.14

		```

		Puedes realizar operaciones matemáticas con números, como suma, resta, multiplicación y división.


		Operaciones Aritméticas: 

			Los números en Python admiten operaciones aritméticas básicas, como suma, resta, multiplicación y división.

			```python

				a = 5
				b = 3

				suma = a + b  # Suma: 8
				resta = a - b  # Resta: 2
				multiplicacion = a * b  # Multiplicación: 15
				division = a / b  # División: 1.666...

			```


		Precisión de Punto Flotante: 
		
			Los números de punto flotante (float) pueden representar números reales, pero pueden tener limitaciones de precisión debido a la representación binaria.	

			```python

				x = 0.1 + 0.1 + 0.1  # Puede no ser exactamente 0.3 debido a la precisión de punto flotante

			```


		Modulo math: 

			Admite operaciones matemáticas más avanzadas utilizando funciones incorporadas del módulo 

			```python

				import math

				raiz_cuadrada = math.sqrt(16)  # Raíz cuadrada: 4.0
				potencia = math.pow(2, 3)  # Potencia: 8.0

			```


		Redondeo y Truncamiento: 

			Puedes redondear números utilizando las funciones incorporadas round(), math.floor() y math.ceil().

			```python

				x = 3.7
				redondeado = round(x)  # Redondeo: 4
				truncado = math.floor(x)  # Truncamiento: 3

			```


		Conversiones de Tipo: 

			Puedes convertir números de un tipo a otro utilizando funciones incorporadas, como int() y float().

			```python

				entero = int(5.3)  # Conversión a entero: 5
				decimal = float(10)  # Conversión a decimal: 10.0

			```


		Operadores Numéricos Especiales: 

			Python también proporciona operadores especiales para realizar divisiones enteras y obtener el resto.

			```python

				division_entera = 7 // 3  # División entera: 2
				resto = 7 % 3  # Resto: 1

			```


		Comparaciones Numéricas: 

			Puedes comparar números utilizando operadores de comparación como <, >, <=, >=, == y !=.

			```python

				a = 5
				b = 3

				es_mayor = a > b  # Verdadero
				es_igual = a == b  # Falso

			```


	Listas (list):
		
		Las listas son colecciones o secuencias ordenadas de elementos mutables. 

		Pueden contener elementos de diferentes tipos.

		```python

			numeros = [1, 2, 3, 4]
			nombres = ["Alice", "Bob", "Charlie"]

		```	

		Puedes acceder a elementos individuales de una lista utilizando índices y realizar diversas operaciones como agregar elementos, eliminar elementos y modificar elementos existentes.


	    Orden: 

	    	Los elementos en una lista están ordenados y se almacenan en posiciones específicas. 

	    	Puedes acceder a elementos individuales utilizando índices.

	    	```python

	    		numeros = [1, 2, 3, 4]
				primer_numero = numeros[0]  # Devuelve 1

	    	```


	    Mutabilidad: 

	    	Las listas son mutables, lo que significa que puedes modificar, agregar y eliminar elementos después de crear la lista.


		Agregar Elementos:

			Puedes agregar elementos a una lista utilizando el método .append() o la concatenación.

			```python

				frutas = ["manzana", "banana", "naranja"]
				frutas.append("kiwi")  # Agrega "kiwi" al final de la lista


			```
		

		Modificar Elementos: 

			Puedes modificar elementos en una lista utilizando índices.

			```python

				numeros = [1, 2, 3, 4]
				numeros[1] = 5  # Cambia el segundo elemento a 5

			```


		Eliminar Elementos: 

			Puedes eliminar elementos de una lista utilizando los métodos .remove() y .pop().

			```python

				colores = ["rojo", "verde", "azul"]
				colores.remove("verde")  # Elimina "verde" de la lista
				ultimo_color = colores.pop()  # Elimina el último elemento y lo devuelve

			```


    	Operaciones de Lista: 

    		Python proporciona una variedad de operaciones incorporadas para trabajar con listas, como:

		    .len(): Devuelve la longitud de la lista.

		    .count(): Cuenta cuántas veces aparece un elemento en la lista.

		    .index(): Encuentra el índice de un elemento en la lista.

		    ```python

		    	numeros = [1, 2, 3, 2, 4, 5, 2]
				longitud = len(numeros)  # Devuelve 7
				veces_dos_aparece = numeros.count(2)  # Devuelve 3
				indice_cuatro = numeros.index(4)  # Devuelve 4

		    ```


		Ordenar y Revertir: 
		
			Puedes ordenar una lista con el método .sort() y revertir el orden con el método .reverse().   

			```python

				numeros = [4, 1, 3, 2]
				numeros.sort()  # Ordena la lista en orden ascendente
				numeros.reverse()  # Revierte el orden de la lista

			```


		Segmentación de Listas:

			Puedes segmentar (cortar) una lista para obtener sublistas.

			```python

				frutas = ["manzana", "banana", "naranja", "kiwi"]
				subfrutas = frutas[1:3]  # Devuelve ["banana", "naranja"]

			```


	Tuplas (tuple):
		
		Las tuplas son similares a las listas, pero son inmutables, lo que significa que no puedes cambiar sus elementos después de crearlas.

		```python

			coordenadas = (3, 5)
			dias_semana = ("Lunes", "Martes", "Miércoles")

		```


		Inmutabilidad: 

			A diferencia de las listas, las tuplas no se pueden modificar después de crearlas. 

			Una vez que creas una tupla, no puedes agregar, modificar o eliminar elementos.


		Orden: 

			Los elementos en una tupla están ordenados y se almacenan en posiciones específicas. 

			Puedes acceder a elementos individuales utilizando índices


			```python

				coordenadas = (3, 5)
				primer_elemento = coordenadas[0]  # Devuelve 3

			```


		Indexación y Segmentación:

			Al igual que las listas, puedes acceder a elementos individuales de una tupla utilizando índices. 

			También puedes segmentar (cortar) tuplas para obtener sub-tuplas.

			```python

				mi_tupla = (1, 2, 3, 4, 5)
				primer_elemento = mi_tupla[0]  # Devuelve 1
				sub_tupla = mi_tupla[1:3]  # Devuelve (2, 3)

			```


		Desempaquetado de Tuplas: 

			Puedes asignar elementos individuales de una tupla a variables utilizando el desempaquetado de tuplas.

			```python

				punto = (3, 5)
				x, y = punto  # x será 3, y será 5

			```


		Concatenación y Repetición: 	

			Puedes concatenar tuplas utilizando el operador +. También puedes repetir una tupla utilizando el operador *.

			```python

				tupla1 = (1, 2)
				tupla2 = (3, 4)
				tupla_concatenada = tupla1 + tupla2  # Devuelve (1, 2, 3, 4)
				tupla_repetida = tupla1 * 3  # Devuelve (1, 2, 1, 2, 1, 2)

			```


		Funciones de Tupla: 

			Python proporciona funciones incorporadas que trabajan con tuplas, como len(), min(), max() y sum().

			```python

				mi_tupla = (10, 5, 7, 3)
				longitud = len(mi_tupla)  # Devuelve 4
				valor_minimo = min(mi_tupla)  # Devuelve 3
				valor_maximo = max(mi_tupla)  # Devuelve 10
				suma = sum(mi_tupla)  # Devuelve 25

			```

			Son útiles cuando deseas crear una colección de elementos que no deberían cambiar después de su creación. 

			Se utilizan en situaciones donde la inmutabilidad es deseable, como para representar coordenadas, nombres de meses, puntos de datos fijos, etc.


	Conjuntos (set):
		
		Los conjuntos son colecciones no ordenadas de elementos únicos.

		```python

			frutas = {"manzana", "banana", "naranja"}

		```

		Son útiles para realizar operaciones de conjuntos como unión, intersección y diferencia.


		Elementos Únicos: 

			Los conjuntos no pueden contener elementos duplicados. 

			Si intentas agregar un elemento que ya está en el conjunto, no se agregará nuevamente.

			```python

				frutas = {"manzana", "banana", "naranja", "banana"}  # "banana" solo aparece una vez en el conjunto

			```


		No tienen Orden: 

			Los elementos en un conjunto no tienen un orden específico. 

			No puedes acceder a elementos individuales mediante índices.


		Agregar y Eliminar Elementos: 		
			Puedes agregar elementos a un conjunto utilizando el método .add() y eliminar elementos utilizando el método .remove().

			```python

				colores = {"rojo", "verde", "azul"}
				colores.add("amarillo")  # Agrega "amarillo" al conjunto
				colores.remove("verde")  # Elimina "verde" del conjunto

			```


		Comprobación de Pertenencia: 

			Puedes verificar si un elemento está presente en un conjunto utilizando el operador in.

			```python

				frutas = {"manzana", "banana", "naranja"}
				if "banana" in frutas:
    				print("Banana está en el conjunto.")

			```


		Operaciones de Conjuntos: 

			Python proporciona una variedad de operaciones incorporadas para trabajar con conjuntos, como:

		    .union(): Realiza la unión de dos conjuntos.

		    .intersection(): Realiza la intersección de dos conjuntos.

		    .difference(): Calcula la diferencia entre dos conjuntos.

		    .issubset(): Comprueba si un conjunto es un subconjunto de otro.

		    .issuperset(): Comprueba si un conjunto es un superconjunto de otro.

		    ```python

		    	conjunto1 = {1, 2, 3}
				conjunto2 = {3, 4, 5}
				union = conjunto1.union(conjunto2)  # Devuelve {1, 2, 3, 4, 5}
				interseccion = conjunto1.intersection(conjunto2)  # Devuelve {3}

		    ```


		Operaciones de Conjunto Modificadas: 

			Además de los métodos mencionados anteriormente, Python también proporciona versiones modificadas de estos métodos, como .update(), .intersection_update(), .difference_update(), que modifican el conjunto en lugar de crear uno nuevo.

			```python

				conjunto1 = {1, 2, 3}
				conjunto2 = {3, 4, 5}
				conjunto1.update(conjunto2)  # Modifica conjunto1 a {1, 2, 3, 4, 5}

			```




	Diccionarios (dict):
		
		Los diccionarios son colecciones de pares clave-valor. 

		Cada valor está asociado con una clave única.

		```python

			persona = {"nombre": "Alice", "edad": 25, "altura": 1.75}

		```

		Puedes acceder a valores utilizando claves y realizar operaciones como agregar nuevos pares clave-valor, modificar valores y eliminar entradas.


		Pares Clave-Valor: 

			Los diccionarios almacenan elementos como pares clave-valor, donde cada clave es única y está asociada con un valor específico.

			```python

				persona = {"nombre": "Alice", "edad": 30, "ciudad": "Nueva York"}

			```


		Mutabilidad: 

			Los diccionarios son mutables, lo que significa que puedes agregar, modificar y eliminar elementos después de crear el diccionario.


		Acceso a Valores: 

			Puedes acceder a valores en un diccionario utilizando las claves correspondientes.

			```python

				persona = {"nombre": "Alice", "edad": 30}
				nombre = persona["nombre"]  # Devuelve "Alice"

			```


		Modificación y Adición de Elementos: 

			Puedes modificar valores existentes en un diccionario y también agregar nuevos pares clave-valor.

			
			```python

				persona = {"nombre": "Alice", "edad": 30}
				persona["edad"] = 31  # Modifica el valor de "edad"
				persona["ciudad"] = "Nueva York"  # Agrega un nuevo par clave-valor

			```


		Eliminación de Elementos: 

			Puedes eliminar elementos de un diccionario utilizando la instrucción del o el método .pop().

			```python

				persona = {"nombre": "Alice", "edad": 30}
				del persona["edad"]  # Elimina el par clave-valor "edad"
				ciudad = persona.pop("ciudad")  # Elimina y devuelve el valor asociado a "ciudad"

			```

		
		Verificación de Existencia de Claves: 

			Puedes verificar si una clave específica existe en un diccionario utilizando el operador in.

			```python

				persona = {"nombre": "Alice", "edad": 30}
				if "nombre" in persona:
				    print("La clave 'nombre' existe en el diccionario.")

			```			


		Obtención de Claves y Valores: 

			Puedes obtener una lista de todas las claves o valores en un diccionario utilizando los métodos .keys() y .values() respectivamente.

			```python

				persona = {"nombre": "Alice", "edad": 30}
				claves = persona.keys()  # Devuelve ["nombre", "edad"]
				valores = persona.values()  # Devuelve ["Alice", 30]

			```


		Obtención de Pares Clave-Valor: 	
			Puedes obtener una lista de tuplas que contienen pares clave-valor utilizando el método .items().

			```python

				persona = {"nombre": "Alice", "edad": 30}
				pares = persona.items()  # Devuelve [("nombre", "Alice"), ("edad", 30)]

			```


	Booleanos (bool):
		
		Los booleanos representan valores de verdadero (True) o falso (False). 

		Se utilizan en expresiones de control de flujo y para tomar decisiones.

		```python

			verdadero = True
			falso = False

		```


		Valores Constantes: 

			Los valores booleanos solo pueden ser True o False, que son constantes incorporadas en Python.


    	Operaciones de Lógica: 

    		Los valores booleanos son fundamentales para las operaciones lógicas como la negación (not), la conjunción (and) y la disyunción (or).


			```python

				a = True
				b = False

				negacion_a = not a  # Falso
				conjuncion = a and b  # Falso
				disyuncion = a or b  # Verdadero

			```


    	Comparaciones: 

    		Puedes realizar comparaciones entre valores utilizando operadores de comparación como == (igual), != (distinto), < (menor que), > (mayor que), <= (menor o igual que), >= (mayor o igual que).

    		```python

    			x = 5
				y = 10
				es_igual = x == y  # Falso
				es_menor = x < y  # Verdadero

    		```


		Comprobación de Pertinencia: 

			Puedes verificar si un valor está contenido en una colección utilizando el operador in.    		

			```python

				numeros = [1, 2, 3, 4, 5]
				tiene_tres = 3 in numeros  # Verdadero

			```


		Control de Flujo: 

			Los valores booleanos se utilizan para controlar el flujo de ejecución en estructuras de control condicionales como if, elif y while.

			```python

				edad = 18
				if edad >= 18:
				    print("Eres mayor de edad")
				else:
				    print("Eres menor de edad")

			```


		Funciones que Retornan Valores Booleanos: 

			Muchas funciones incorporadas en Python retornan valores booleanos para indicar si una condición se cumple. 

			Por ejemplo, el método .startswith() de las cadenas devuelve True si la cadena comienza con una subcadena específica.

			```python

				mensaje = "Hola, mundo"
				comienza_con_hola = mensaje.startswith("Hola")  # Verdadero

			```


		Conversión desde Otros Tipos:

			Puedes convertir otros tipos de datos a valores booleanos utilizando la función incorporada bool(). 

			Cualquier valor numérico diferente de cero o cualquier cadena no vacía se convierte en True, mientras que el valor numérico cero o una cadena vacía se convierten en False.

			```python

				valor_entero = 5
				valor_booleano = bool(valor_entero)  # Verdadero

				cadena_vacia = ""
				valor_booleano2 = bool(cadena_vacia)  # Falso

			```


	None:
		
		None es un tipo de dato especial que representa la ausencia de valor. 

		Se utiliza comúnmente para indicar que una variable no tiene un valor asignado.

		```python

			resultado = None

		```	


		Valor Único: 

			El valor None es único y no se puede comparar con otros valores de manera significativa. 

			No es igual a ningún otro valor, incluyendo otros valores None.	

			```python

				x = None
				y = None
				es_igual = x == y  # Verdadero

			```


		No es Falso: 

			Aunque None se evalúa como falso en contextos booleanos, no es igual a False. 

			Es importante recordar que None representa la ausencia de valor, no el valor booleano falso.


		Asignación Inicial: 

			A menudo, None se utiliza para inicializar variables antes de asignarles un valor específico.

			```python

				resultado = None

			```


		Valor de Retorno Predeterminado: 

			Las funciones pueden tener un valor de retorno predeterminado de None. 

			Si no se especifica un valor de retorno, la función devolverá automáticamente None.

			```python

				def funcion_vacia():
			    pass  # No tiene un return, por lo tanto, retorna None automáticamente

			```

		
		Comprobación de Valores Nulos: 

			Se utiliza para comprobar si una variable o una expresión no contiene un valor asignado. 

			Esto puede ser útil para evitar errores en casos donde se espera un valor pero no se tiene uno.

			```python

				resultado = realizar_alguna_operacion()
				if resultado is None:
				    print("La operación no produjo un resultado válido.")

			```


		Comparación con is: 

			En lugar de usar el operador de igualdad (==) para verificar si algo es None, es preferible usar el operador is.

			```python

				valor = None
				if valor is None:
				    print("El valor es None.")

			```


		Funciones que No Retornan Valores: 

			Las funciones que no tienen una instrucción de retorno (o que solo contienen return sin argumentos) retornarán implícitamente None.	

			```python

				def funcion_sin_retorno():
				    print("Esta función no retorna nada.")

				resultado = funcion_sin_retorno()  # resultado será None

			```



|| CONDICIONALES O COMPARADORES

	Son operadores que se utilizan para comparar dos valores y evaluar condiciones.

	Se utilizan en estructuras de control como declaraciones if, bucles while y for, y expresiones condicionales.

	Al combinarlos con operadores lógicos (and, or, not), puedes crear condiciones más complejas para controlar el flujo de tu programa y tomar decisiones fundamentadas en diferentes situaciones.


	Valores de Comparación: 

		Los comparadores toman dos valores y los comparan para determinar la relación entre ellos. 

		Los valores pueden ser variables, constantes o expresiones.


    Resultados Booleanos: 

    	Los comparadores siempre devuelven un valor booleano, es decir, True (verdadero) o False (falso), dependiendo del resultado de la comparación.


    Igual (==): 

    	Compara si dos valores son iguales.

    	```python

    		x = 5
			y = 5
			resultado = x == y  # Devuelve True

    	```


   Distinto (!=): 

   	Compara si dos valores son diferentes.

   	```python

   		x = 5
		y = 10
		resultado = x != y  # Devuelve True

   	```


    Mayor que (>): 

    	Compara si el valor de la izquierda es mayor que el valor de la derecha.

    	```python

    		x = 10
			y = 5
			resultado = x > y  # Devuelve True

    	```


	Menor que (<): 

		Compara si el valor de la izquierda es menor que el valor de la derecha. 
		

		```python

			x = 5
			y = 10
			resultado = x < y  # Devuelve True

		```   


	Mayor o igual que (>=): 

		Compara si el valor de la izquierda es mayor o igual al valor de la derecha.

		```python

			x = 10
			y = 5
			resultado = x >= y  # Devuelve True

		```


	Menor o igual que (<=): 

		Compara si el valor de la izquierda es menor o igual al valor de la derecha.

		```python

			x = 5
			y = 10
			resultado = x <= y  # Devuelve True

		```



|| CONVERSIÓN DE TIPOS DE DATOS

	"Type Conversion" o "Casting", se refiere al proceso de cambiar el tipo de un objeto de datos de un tipo a otro. 

	Esto es útil cuando necesitas operar o trabajar con valores de diferentes tipos en una expresión o en una operación específica.


	Implicit Type Casting (Casting Implícito): 

		También conocido como "coerción", ocurre automáticamente cuando Python convierte automáticamente un tipo de dato en otro para realizar una operación. 

		Por ejemplo, cuando sumas un entero con un número de punto flotante, Python convierte automáticamente el entero en un flotante para realizar la operación.

		```python

			x = 5         # int
			y = 2.5       # float
			resultado = x + y  # Aquí ocurre un casting implícito de int a float

		```


	Explicit Type Casting (Casting Explícito): 

		Esto implica cambiar deliberadamente el tipo de un objeto de datos utilizando funciones incorporadas. 

		Al hacer esto, tienes un mayor control sobre cómo se realiza la conversión y puedes evitar errores inesperados.


	int(): Convierte un valor a un entero.

    float(): Convierte un valor a un número de punto flotante.

    str(): Convierte un valor a una cadena.

    bool(): Convierte un valor a un valor booleano.

    list(): Convierte un valor a una lista.

    tuple(): Convierte un valor a una tupla.

    ```python

    	valor_entero = 5
		valor_flotante = float(valor_entero)  # Convierte a float

		cadena_numero = "10"
		valor_entero_desde_cadena = int(cadena_numero)  # Convierte a int

		booleano = bool(1)  # Convierte a True, ya que 1 es considerado verdadero

    ```

    No todas las conversiones de tipo son válidas. 

    Por ejemplo, no puedes convertir una cadena que no represente un número en un entero o flotante. 

    Si intentas realizar una conversión que no es posible, Python arrojará una excepción llamada ValueError.

    Útil para manipular datos y asegurarse de que estás operando con los tipos de datos correctos en diferentes situaciones. 

    Sin embargo, es importante usarlo con precaución y asegurarse de que las conversiones sean apropiadas para evitar errores y comportamientos inesperados en tu código.
  	  


|| EXCEPCIONES 

	Conocidas como "errores" o "excepciones de error" son eventos que ocurren durante la ejecución de un programa y que interrumpen el flujo normal del programa debido a situaciones inesperadas o no manejadas. 

	Cuando una excepción se produce, el programa normalmente se detiene y el control se transfiere a un bloque de código diseñado para manejar la excepción.

	Permiten a los programadores manejar situaciones de error de manera elegante y controlada, en lugar de que el programa simplemente se detenga con un mensaje de error o se cierre abruptamente en caso de problemas.


	Lanzamiento de Excepciones: 

		Cuando ocurre una situación excepcional en el código, como una división por cero o el acceso a una variable que no está definida, Python lanza una excepción específica para esa situación.


    Captura de Excepciones: 

    	Puedes usar bloques try y except para capturar excepciones y manejarlas de manera adecuada. 

    	El bloque try contiene el código que podría causar una excepción, y el bloque except contiene el código que se ejecutará si se lanza una excepción.


    ```python

    	try:
	    numero = 10 / 0  # Intenta dividir por cero, lo cual lanza una excepción
		except ZeroDivisionError:
		    print("Error: División por cero")

    ```

    Manejo de Varios Tipos de Excepciones: 

    	Puedes manejar diferentes tipos de excepciones en bloques except separados para realizar acciones específicas según el tipo de error.

    	```python

    		try:
			    valor = int("texto")  # Intenta convertir una cadena no numérica a entero
			except ValueError:
			    print("Error: Valor no numérico")
			except TypeError:
			    print("Error: Tipo incorrecto")

    	```


    Bloque else: 

    	Puedes usar un bloque else después del bloque try y except para ejecutar código si no se produce ninguna excepción.

    	```python

    		try:
			    archivo = open("archivo.txt", "r")
			except FileNotFoundError:
			    print("Error: El archivo no existe")
			else:
			    contenido = archivo.read()
			    archivo.close()

    	```


    Bloque finally: 

    	Puedes usar un bloque finally después de un bloque try y except para ejecutar código que siempre debe ejecutarse, independientemente de si se lanzó una excepción o no.

    	```python

    		try:
			    # Código que puede lanzar una excepción
			except SomeException:
			    # Manejo de la excepción
			finally:
			    # Código que siempre se ejecutará

    	```



|| FUNCIONES 

	Se utilizan en una variedad de casos para organizar, reutilizar y simplificar el código.


	Reutilización de Código: 

		Una de las principales ventajas de las funciones es la reutilización de código. 

		Puedes definir una función una vez y llamarla en múltiples lugares del programa, lo que evita la duplicación de código.


    Abstracción: 

    	Las funciones permiten abstraer detalles complejos. 

    	Puedes encapsular un conjunto de instrucciones complejas en una función con un nombre descriptivo, lo que facilita la lectura y comprensión del código.


    Modularidad: 

    	Divide tu código en módulos más pequeños y manejables. 

    	Cada función realiza una tarea específica, lo que facilita la organización del código y el mantenimiento a medida que el programa crece.


    Encapsulación: 

    	Puedes ocultar la implementación interna de una función y solo proporcionar una interfaz pública. 

    	Esto mejora la seguridad y evita que otros desarrolladores accedan directamente a partes internas del código.


    Legibilidad: 

    	Usar funciones con nombres descriptivos mejora la legibilidad del código, ya que comunica la intención y funcionalidad de manera clara.


    Debugging y Mantenimiento: 

    	Si encuentras un error en una función, solo necesitas corregirlo en un lugar. 

    	Esto evita la necesidad de cambiarlo en múltiples partes del programa.


    Manejo de Excepciones: 

    	Las funciones pueden encapsular bloques de código que podrían generar excepciones y manejar esas excepciones de manera centralizada.


    Programación Modular: 

    	En proyectos grandes, puedes dividir tareas complejas en funciones más pequeñas y luego combinar esas funciones para lograr la funcionalidad deseada.


    Funciones Matemáticas: 

    	Las funciones son útiles para encapsular fórmulas matemáticas o cálculos repetitivos.


    Interacción con Archivos y Red: 	

    	Puedes encapsular la lógica de interacción con archivos, bases de datos o redes en funciones para facilitar el manejo de datos.


    Transformación de Datos: 

    	Las funciones son útiles para transformar datos en diferentes formatos o realizar operaciones específicas en conjuntos de datos.


    Interfaz de Usuario: 

    	En aplicaciones, puedes usar funciones para encapsular la lógica de la interfaz de usuario, como la validación de entradas.


    Procesamiento de Texto: 

    	Funciones para el procesamiento de cadenas, como dividir, unir y reemplazar texto.


    Ejemplos: 

    	```python

    		# Definición de una función simple
			def saludar(nombre):
			    """
			    Esta función saluda a la persona cuyo nombre se proporciona.
			    """
			    print("Hola,", nombre)

    		# Llamada a la función
			saludar("Alice")  # Salida: Hola, Alice

			# Función con valor de retorno
			def sumar(a, b):
			    """
			    Esta función suma dos números y retorna el resultado.
			    """
			    resultado = a + b
			    return resultado
    	```


|| FUNCIÓN ANÓNIMA
	
	En Python se llaman "funciones lambda". 

	Son funciones pequeñas y anónimas que se pueden definir en una sola línea de código. 

	A diferencia de las funciones normales definidas con la palabra clave def, las funciones lambda no tienen un nombre asociado y se utilizan en situaciones donde necesitas una función simple para una tarea específica.

	Son limitadas en cuanto a su complejidad y funcionalidad en comparación con las funciones definidas con def. 

	Por lo tanto, se recomienda usarlas principalmente para tareas pequeñas y simples.

	```python

		lambda argumentos: expresion

	```

	lambda: 

		Es la palabra clave que indica que estás definiendo una función lambda.

    argumentos: 

    	Son los parámetros de entrada de la función lambda, separados por comas.

    expresion: 

    	Es la expresión que se evalúa y se devuelve como resultado de la función.


    ```python

    	# Definición de una función lambda que suma dos números
		sumar = lambda x, y: x + y

		resultado = sumar(5, 3)  # resultado = 8

		# Uso de una función lambda en una función incorporada como sorted()
		numeros = [1, 4, 2, 8, 5]
		numeros_ordenados = sorted(numeros, key=lambda x: x % 2)
		# números_ordenados = [2, 4, 8, 1, 5]

    ```

    En la primera función, 'sumar' es una función lambda que toma dos argumentos x e y, y devuelve su suma.

    La segunda función, se utiliza la función lambda como argumento en la función incorporada sorted() para ordenar una lista de números según su residuo de la división por 2, lo que resulta en una lista con números pares primero y luego los impares.


    Casos de uso: 

    	Ordenamiento Personalizado: 

    		Cuando necesitas ordenar una lista de objetos utilizando un criterio específico, puedes usar una función lambda como argumento en funciones como sorted().


	    Transformación de Datos: 

	    	Cuando deseas aplicar una operación simple a cada elemento de una lista o iterador, como elevar al cuadrado o convertir a mayúsculas.


	    Filtrado de Datos: 

	    	Al filtrar elementos de una lista o iterador basado en una condición específica.


	    Claves de Ordenamiento: 

	    	En situaciones donde necesitas definir una clave de ordenamiento para funciones como sorted() o max().


	    Funciones de Map y Filter: 

	    	En la aplicación de funciones a cada elemento de una lista usando map() o en la filtración de elementos usando filter().


	    Callbacks: 

	    	Cuando se requiere una función para ser pasada como argumento a otra función, como en el caso de funciones de manejo de eventos.


	    Operaciones Matemáticas Simples:

	    	Para operaciones aritméticas o matemáticas simples que se deben aplicar a valores.


	    Validación: 

	    	En la validación de entradas o en la verificación de condiciones específicas.


	    Cálculos de Fórmulas: 

	    	Para cálculos matemáticos o fórmulas simples en situaciones donde no se necesita una función completa.


	    Tratamiento de Strings: 

	    	En operaciones de manipulación de cadenas, como concatenación o formato.


	    Definición de Interfaces de Callback: 

	    	En la definición de interfaces de devolución de llamada en bibliotecas o marcos de trabajo.


	    Operaciones con Listas: 

	    	En la realización de operaciones específicas en listas, como obtener el elemento máximo o mínimo.



|| Función Autoinvocada

	Puedes lograr el mismo efecto utilizando funciones anónimas (lambda) o simplemente llamando a una función inmediatamente después de definirla. 

	Estas técnicas se usan para crear funciones que se ejecutan automáticamente sin necesidad de ser llamadas explícitamente.


	Funciones lambda: 

		Pueden ser invocadas en el mismo momento en que se definen. 

		Son útiles para tareas pequeñas y puntuales.

		```python

			resultado = (lambda x: x * 2)(5)  # resultado = 10

		```

		En este ejemplo, la función lambda se define y se invoca inmediatamente con el valor 5 como argumento.


	Definir y Llamar inmediatamente:

		Puedes definir una función y luego llamarla inmediatamente después de su definición en la estructura del código.

		```python

			def suma(a, b):
			    return a + b

			resultado = suma(3, 4)  # resultado = 7

		```



|| FUNCION RECURSIVA
	
	Son funciones que se llaman a sí mismas para resolver un problema. 

	En esencia, una función recursiva se divide en subproblemas más pequeños del mismo tipo hasta que se alcanza un caso base en el que el problema es lo suficientemente simple para resolverse directamente.
	

	```python

		def funcion_recursiva(parametros):
	    # Caso Base: Condición que detiene la recursión.
	    if condicion_base:
	        return valor_base

	    # Caso Recursivo: Llamada a la función recursiva con argumentos modificados.
	    resultado = funcion_recursiva(parametros_modificados)
	    return resultado

	```

	Caso Base:

		Esta es la condición que detiene la recursión. 

		Cuando se cumple esta condición, la función no se llama a sí misma y devuelve un valor predefinido.

		Sin un caso base adecuado, la función recursiva podría entrar en un bucle infinito.


    Caso Recursivo: 

    	En esta parte, la función se llama a sí misma con argumentos modificados para acercarse al caso base. 

    	La llamada recursiva debe modificar al menos un parámetro de manera que el problema sea más pequeño o más simple en cada iteración.


    Ejemplos: 

    ```python

    	def factorial(n):
	    	# Caso Base: El factorial de 0 es 1.
	    	if n == 0:
	        return 1
	    	# Caso Recursivo: Llamada a la función con n-1.
	    	else:
	        	return n * factorial(n - 1)

		resultado = factorial(5)  # resultado = 120

    ```

    El caso base es cuando n es igual a 0, y la función devuelve 1.

    El caso recursivo es cuando n es mayor que 0, y la función se llama a sí misma con n - 1. Esto se repite hasta que se alcanza el caso base.

	Ten en cuenta que es fundamental que cada llamada recursiva se acerque al caso base para evitar bucles infinitos.


	Casos de uso: 

		Cálculos Matemáticos:

        	Factorial: 

        		Calcular el factorial de un número.

       		Fibonacci: 

       			Generar la secuencia de Fibonacci.

        	Potencia: 

        		Calcular una potencia de un número.

        	Máximo Común Divisor (MCD):
        	 	Encontrar el MCD de dos 	números.


	    Recorrido de Estructuras de Datos:

	        Recorrido de Árboles: 

	        	Explorar árboles binarios o estructuras de árbol más complejas.

	        Recorrido de Grafos: 

	        	Explorar grafos para encontrar caminos o conexiones.

	        Recorrido de Listas Ligadas: 

	        	Navegar por listas ligadas o estructuras de datos similares.


	    Resolución de Problemas Divide y Vencerás:

	        Ordenamiento: 

	        	Algunos algoritmos de ordenamiento, como Quicksort y Mergesort, utilizan recursión.

	        Búsqueda Binaria: 

	        	Buscar elementos en una lista ordenada de manera eficiente.

	        División de Problemas Geométricos: 

	        	Resolver problemas geométricos al dividirlos en subproblemas más pequeños.


	    Tareas Combinatorias:

	        Generación de Permutaciones y Combinaciones: 

	        	Encontrar todas las permutaciones o combinaciones de un conjunto de elementos.


	    Problemas de Juegos y Rompecabezas:

	        Torres de Hanoi: 

	        	Resolver el famoso problema de las Torres de Hanoi.

	        Resolver Sudoku: 

	        	Encontrar soluciones para juegos de Sudoku.


	    Estructuras de Datos Recursivas:

	        Listas Ligadas Recursivas: 

	        	Crear y manipular listas ligadas recursivamente.

	        Árboles Recursivos: 

	        	Implementar estructuras de árboles recursivos.


	    Análisis de Texto:

	        Análisis de Sintaxis: 

	        	Algunos analizadores de lenguaje natural utilizan recursión para analizar la estructura de una oración.


	    Algoritmos de Búsqueda:

	        Búsqueda de Caminos: 

	        	Encontrar caminos en laberintos o mapas.


	    Problemas de Combinatoria:

	        Generación de Subconjuntos:

	        	Encontrar todos los subconjuntos de un conjunto de elementos.



|| FUNCIÓN CLOSURE
	
	Es una función que retiene el entorno léxico en el que se creó, incluso cuando esa función se ejecuta fuera de ese entorno léxico. 

	En otras palabras, un closure permite que una función capture y mantenga las variables locales y parámetros de la función que la rodea, incluso después de que esa función haya terminado su ejecución. 

	Esto permite que la función interna (closure) acceda a esas variables y las utilice más adelante.

	Son útiles cuando deseas tener una función que mantenga ciertos valores o estado específico entre llamadas.

	Esto puede ser especialmente útil en situaciones como la programación asíncrona, la implementación de decoradores y la creación de funciones fábrica.

	```python

		def exterior(x):
		    def interior(y):
		        return x + y
		    return interior

		agregar_5 = exterior(5)
		resultado = agregar_5(3)  # resultado = 8

	```

	exterior() es una función que toma un parámetro x y define una función interna llamada interior(). 

	La función interior() utiliza la variable x del ámbito de exterior() incluso después de que exterior() haya terminado su ejecución. 

	Cuando llamamos a exterior(5), devuelve la función interior() con x establecido en 5. 

	Luego, podemos llamar a agregar_5(3) para agregar 3 al valor capturado de x, lo que resulta en 8.


	Casos de uso teóricos: 

		Encapsulación de Datos Privados:

        	Los closures pueden utilizarse para encapsular variables y métodos dentro de una función, ocultándolos al ámbito global y creando una especie de "clase" con datos privados.


	    Gestión de Memoria y Recursos:
	        
	        En situaciones donde necesitas gestionar la asignación y liberación de recursos, como la apertura y cierre de archivos, los closures pueden garantizar que los recursos se liberen adecuadamente al finalizar una función.


	    Implementación de Singleton:

	        Puedes utilizar un closure para implementar el patrón de diseño Singleton, garantizando que solo haya una instancia de una clase en todo el programa.


	    Factory Functions:

	        Las fábricas de objetos son funciones que crean y devuelven instancias de objetos personalizados. 

	        Los closures pueden ser útiles en la creación de fábricas de objetos con propiedades específicas.


	    Manejo de Estado en UI:

	        En el desarrollo de interfaces de usuario (UI), los closures pueden usarse para administrar el estado de componentes específicos, como ventanas emergentes o diálogos modales.


	    Funciones de Orden Superior:

	        En programación funcional, puedes usar closures para crear funciones de orden superior que toman otras funciones como argumentos y devuelven nuevas funciones con comportamientos personalizados.


	    Seguridad y Aislamiento de Datos:
	        
	        Los closures pueden ayudar a garantizar la seguridad y el aislamiento de datos al limitar el acceso a ciertas variables y funciones dentro de un ámbito cerrado.


	    Manejo de Eventos:

	        En entornos de programación de eventos, los closures pueden utilizarse para definir funciones de manejo de eventos personalizadas que se ejecutan cuando ocurre un evento específico.


	    Optimización de Recursos:

	        Los closures pueden ayudar a optimizar el uso de recursos al garantizar que los recursos se inicialicen solo cuando sea necesario y se liberen cuando ya no se necesiten.


	    Implementación de Lógica de Negocio Específica:

	        En aplicaciones empresariales, los closures pueden ser útiles para implementar lógica de negocio específica que varía según el contexto.


	Casos de uso prácticos: 

		Funciones fábrica: 

			Usar closures para crear funciones personalizadas con parámetros predefinidos. 

			Esto es útil cuando deseas generar funciones con configuraciones específicas.

			```python

				def crear_sumador(x):
				    def sumar(y):
				        return x + y
				    return sumar

				sumar_5 = crear_sumador(5)
				resultado = sumar_5(3)  # resultado = 8

			```

		Decoradores:

			Un decorador es una función que envuelve otra función para agregar funcionalidad. 

			Los closures capturan la función original y la modifican de acuerdo con el decorador.

			```python

				def decorador(funcion):
				    def wrapper(*args, **kwargs):
				        print("Antes de llamar a la función")
				        resultado = funcion(*args, **kwargs)
				        print("Después de llamar a la función")
				        return resultado
				    return wrapper

				@decorador
				def saludar(nombre):
				    return f"Hola, {nombre}!"

				mensaje = saludar("Alice")  # mensaje = "Hola, Alice!"

			```


		Manejo de Estados:

			Pueden usarse para mantener estados o información entre llamadas a una función, sin necesidad de variables globales.

			```python

				def contador_incremetal():
				    contador = 0
				    def incrementar():
				        nonlocal contador
				        contador += 1
				        return contador
				    return incrementar

				contar = contador_incremetal()
				print(contar())  # 1
				print(contar())  # 2

			```


		Funciones de orden superior:

			Permiten crear funciones de orden superior que generan y devuelven otras funciones.

			```python

				def generar_operador(op):
				    def operador(a, b):
				        if op == "+":
				            return a + b
				        elif op == "-":
				            return a - b
				        # Otras operaciones
				    return operador

				suma = generar_operador("+")
				resultado = suma(5, 3)  # resultado = 8

			```

		Manejo de Eventos: 

			En programación de GUI (interfaz gráfica de usuario), los closures se utilizan para manejar eventos específicos, como hacer clic en un botón.

			```python

				from tkinter import Tk, Button

				def crear_handler(mensaje):
				    def handler():
				        print(mensaje)
				    return handler

				root = Tk()
				boton1 = Button(root, text="Clic Me", command=crear_handler("Botón 1 clickeado"))
				boton2 = Button(root, text="Clic Me Too", command=crear_handler("Botón 2 clickeado"))
				boton1.pack()
				boton2.pack()
				root.mainloop()

			```


|| FUNCIÓN CALLBACK

	Es una función que se pasa como argumento a otra función. 

	El concepto es bastante simple pero muy poderoso, ya que te permite definir una parte del comportamiento de un programa y luego pasarlo como entrada a otra parte del código.

	Un ejemplo básico para ilustrar cómo funciona un callback:

		Imagina que tienes una función llamada realizar_operacion que toma dos números y una operación matemática como argumentos y devuelve el resultado de esa operación. 

		En lugar de tener una función separada para cada operación (suma, resta, multiplicación, etc.), puedes usar un callback para pasar la operación como función.

		```python

			def realizar_operacion(a, b, operacion):
			    resultado = operacion(a, b)
			    return resultado

			def suma(x, y):
			    return x + y

			def resta(x, y):
			    return x - y

			resultado1 = realizar_operacion(5, 3, suma)   # resultado1 = 8
			resultado2 = realizar_operacion(5, 3, resta)  # resultado2 = 2

		```

		realizar_operacion es la función principal que realiza una operación en dos números.

		En lugar de tener una función separada para cada operación matemática, puedes pasar la operación como un callback.


	Casos de uso: 

	    Manejo de Eventos de Interfaz de Usuario (UI):

        	En aplicaciones con interfaz de usuario, puedes usar callbacks para manejar eventos como clics de botón, movimientos del mouse o pulsaciones de teclas. Por ejemplo, puedes definir 

        	Una función de callback que se ejecute cuando un usuario hace clic en un botón "Guardar".


		Lectura de Archivos Asíncronos:

		    Al leer archivos de manera asincrónica, puedes utilizar callbacks para especificar qué hacer una vez que se haya completado la lectura del archivo. 

		    Esto es común en entornos web y en la lectura de archivos grandes.


		Peticiones de Red:

		    Al realizar peticiones de red a través de API, puedes usar callbacks para manejar la respuesta una vez que los datos se han recibido. 

		    Esto permite que la aplicación continúe funcionando mientras espera la respuesta del servidor.


		Temporizadores y Retrasos:

		    Puedes usar callbacks para ejecutar cierto código después de un retraso específico o después de un período de tiempo determinado. 

		    Esto es útil para tareas programadas y animaciones.


		Manejo de Errores Personalizados:

		    Cuando ocurre un error en una función, puedes utilizar un callback para especificar cómo manejar ese error de manera personalizada. 

		    Por ejemplo, puedes proporcionar una función de callback que se ejecute cuando se produzca un error de red.


		Validación de Datos Personalizada:

		    En la validación de datos, puedes usar callbacks para especificar cómo validar un dato en particular. 

		    Esto permite que el código de validación sea altamente personalizable y se adapte a diferentes requisitos.


		Orden Superior (Higher-Order Functions):

		    En programación funcional, puedes usar callbacks como argumentos para funciones de orden superior, como map, filter y reduce. 

		    Esto permite aplicar funciones personalizadas a elementos de una lista o realizar filtrado basado en criterios específicos.


		Manejo de Excepciones Personalizado:

		    Puedes utilizar callbacks para definir cómo manejar excepciones personalizadas en tu código. 

		    Por ejemplo, puedes proporcionar una función de callback que se llame cuando se genere una excepción específica.


		Personalización de Comportamiento de Bibliotecas y Frameworks:

		    Muchas bibliotecas y frameworks permiten utilizar callbacks para personalizar su comportamiento. 

		    Por ejemplo, en un framework de juegos, puedes proporcionar una función de callback para definir cómo se manejan los eventos de colisión.


		Programación Asíncrona y Paralela:

		    En programación asíncrona y paralela, los callbacks se utilizan para especificar qué hacer cuando una tarea asíncrona se completa, lo que permite un control preciso del flujo de la aplicación.



|| BUILT-IN FUNCTION

	Son funciones integradas en Python son predefinidas que forman parte del lenguaje y están disponibles para su uso en cualquier momento, sin necesidad de importar módulos adicionales. 

	Estas funciones proporcionan funcionalidades básicas y esenciales que cubren una amplia gama de tareas comunes en la programación.


	print(): Muestra información en la consola.

	```python

		print("Hola, mundo!")
	
	```

	len(): Devuelve la longitud (cantidad de elementos) de una secuencia (cadena, lista, tupla, etc.).

	```python

		nombre = "Alice"
		longitud_nombre = len(nombre)  # longitud_nombre = 5

	```

	input(): Lee una entrada del usuario desde la consola.

	```python

		entrada = input("Ingresa tu nombre: ")

	```

	int(), float(), str(), list(), tuple(), dict(), set(): Convierten entre tipos de datos.

	```python

		numero_texto = "42"
		numero = int(numero_texto)

	```

	range(): Genera una secuencia de números en un rango especificado.

	```python

		numeros = range(1, 6)  # Genera una secuencia: 1, 2, 3, 4, 5

	```

	sum(), max(), min(): Calculan la suma, el valor máximo y el valor mínimo de una secuencia de números.

	```python

		numeros = [5, 2, 8, 1, 6]
		suma_total = sum(numeros)  # suma_total = 22
		valor_maximo = max(numeros)  # valor_maximo = 8
		valor_minimo = min(numeros)  # valor_minimo = 1

	```

	sorted(): Ordena una secuencia de elementos.

	```python

		numeros = [5, 2, 8, 1, 6]
		numeros_ordenados = sorted(numeros)  # numeros_ordenados = [1, 2, 5, 6, 8]

	```

	abs(): Devuelve el valor absoluto de un número.

	```python

		valor_negativo = -5
		valor_absoluto = abs(valor_negativo)  # valor_absoluto = 5

	```

	Lista de funciones incorporadas: 

		Funciones de Conversión de Datos:

		    int(): Convierte a entero.

		    float(): Convierte a punto flotante.

		    str(): Convierte a cadena.

		    bool(): Convierte a booleano.

		    list(): Convierte a lista.

		    tuple(): Convierte a tupla.

		    set(): Convierte a conjunto.

		    dict(): Convierte a diccionario.


		Funciones de Iterables:

		    len(): Devuelve la longitud de un iterable.

		    max(): Devuelve el valor máximo en un iterable.

		    min(): Devuelve el valor mínimo en un iterable.

		    sum(): Calcula la suma de los elementos en un iterable.


		Funciones de Secuencia:

		    range(): Genera una secuencia de números.

		    enumerate(): Devuelve índices y elementos de un iterable.

		    zip(): Combina varios iterables en tuplas.


		Funciones de Entrada/Salida:

		    print(): Muestra texto en la consola.

		    input(): Lee la entrada del usuario desde la consola.

		    open(): Abre archivos para lectura o escritura.


		Funciones Matemáticas y Numéricas:

		    abs(): Valor absoluto.

		    round(): Redondea un número.

		    pow(): Potencia.

		    divmod(): Divide y devuelve el cociente y el resto.

		    hex(): Convierte a representación hexadecimal.

		    oct(): Convierte a representación octal.


		Funciones de Listas, Tuplas y Conjuntos:

		    sorted(): Ordena elementos en un iterable.

		    reversed(): Invierte un iterable.

		    any(): Devuelve True si algún elemento es verdadero.

		    all(): Devuelve True si todos los elementos son verdaderos.


		Funciones de Cadenas:

		    len(): Devuelve la longitud de una cadena.

		    str(): Convierte a cadena.

		    join(): Une elementos de una lista en una cadena.

		    split(): Divide una cadena en una lista de subcadenas.


		Funciones de Diccionarios:

		    len(): Devuelve la cantidad de pares clave-valor en un diccionario.

		    keys(): Devuelve las claves como una vista.

		    values(): Devuelve los valores como una vista.

		    items(): Devuelve los pares clave-valor como una vista.

		    get(): Obtiene el valor asociado a una clave.

		    pop(): Elimina y devuelve el valor asociado a una clave.


		Funciones de Control de Flujo:

		    if: Estructura condicional.

		    for: Bucle de iteración.

		    while: Bucle de control.


		Funciones de Manejo de Excepciones:

		    try, except: Captura y maneja excepciones.

		    raise: Genera una excepción




|| ARRAY 
	
	Además de las lista en Python, si necesitas trabajar con arreglos multidimensionales (matrices), puedes utilizar la biblioteca NumPy, que proporciona un tipo de datos llamado "array" que es más eficiente y adecuado para operaciones matemáticas y científicas en comparación con las listas estándar de Python.

	
	Array de NumPy:

   		NumPy es una biblioteca en Python utilizada para la manipulación de datos numéricos.

    	NumPy proporciona el tipo de datos numpy.array, que es una estructura de datos multidimensional que puede contener elementos de un solo tipo de datos, como números.

    	Los arrays de NumPy son eficientes en términos de memoria y rendimiento, lo que los hace adecuados para cálculos científicos y matemáticos.	

    	```python

    		import numpy as np

			mi_array = np.array([1, 2, 3, 4, 5])

    	```

    	En Python, generalmente trabajamos con listas para colecciones de elementos y usamos NumPy para operaciones numéricas más avanzadas que requieren arrays multidimensionales. 

    	El concepto de "array" en Python está más relacionado con las listas y los arrays de NumPy que con una estructura de datos separada llamada "array".


    Casos de uso: 

    	Almacenamiento de Datos: 

    		Las listas se utilizan para almacenar colecciones de elementos, como números, cadenas, objetos, etc. 

    		Por ejemplo, una lista podría almacenar los puntajes de un juego, los nombres de los estudiantes en una clase, los productos en un carrito de compras en línea, etc.


	    Acceso a Elementos: 

	    	Las listas permiten acceder rápidamente a elementos específicos utilizando un índice. 

	    	Puedes acceder al primer elemento de una lista con lista[0], al segundo con lista[1], y así sucesivamente.


	    Iteración: 

	    	Puedes utilizar un bucle for para iterar a través de los elementos de una lista y realizar una acción en cada elemento. 

	    	Esto es útil para procesar datos o realizar cálculos en una colección de elementos.


	    Ordenamiento de Datos: 

	    	Puedes ordenar los elementos de una lista utilizando funciones como sorted() o métodos como sort(). 

	    	Esto es útil cuando necesitas organizar datos en un orden específico.


	    Búsqueda de Elementos: 

	    	Puedes buscar un elemento específico en una lista utilizando la función in o el método index(). 

	    	Esto es útil para verificar si un elemento existe en la lista y encontrar su posición.


	    Modificación de Datos: 

	    	Puedes agregar, eliminar o modificar elementos en una lista según sea necesario. 

	    	Esto es útil para mantener y actualizar datos en tiempo real.


	    Pilas y Colas: 	

	    	Las listas se pueden utilizar para implementar estructuras de datos como pilas (stacks) y colas (queues), que son útiles para gestionar datos en un orden específico, como el procesamiento de tareas en un sistema.


	    Almacenamiento de Historial: 

	    	Las listas se utilizan comúnmente para mantener un historial de acciones o eventos en una aplicación. 

	    	Por ejemplo, un historial de navegación web podría implementarse como una lista de URLs visitadas.


	    Almacenamiento de Datos de Configuración: 

	    	Las listas son útiles para almacenar datos de configuración, como opciones de usuario, preferencias de aplicación, configuraciones de juegos, etc.


	    Manejo de Datos de Sensores: 

	    	En aplicaciones de ciencia de datos e IoT, las listas se utilizan para recopilar y procesar datos de sensores, como lecturas de temperatura, humedad, presión, etc.


	    Implementación de Algoritmos: 

	    	Las listas son una estructura de datos esencial en la implementación de algoritmos y estructuras de datos más complejas, como árboles, grafos y matrices.



|| LINKED LIST

	Es una estructura de datos que consta de nodos que están enlazados entre sí. 

	Son útiles cuando necesitas una estructura de datos que te permita insertar y eliminar elementos con eficiencia en el medio de la secuencia, a diferencia de las listas estáticas, como las listas en Python (list), que tienen un tamaño fijo. 

	Sin embargo, las linked lists suelen requerir más memoria debido a las referencias adicionales entre los nodos.


	Cada nodo contiene dos elementos principales:

    	Valor o Datos: 

    		El valor que se almacena en el nodo, que puede ser cualquier tipo de dato, como números, cadenas, objetos, etc.


    	Referencia al Siguiente Nodo: 

    		Un enlace (referencia) al siguiente nodo en la lista o un valor especial (como None o null) para indicar el final de la lista.

	
	Las linked lists se utilizan para organizar datos en una secuencia lineal, y existen varios tipos de linked lists, incluyendo:

		1. Singly Linked List (Lista Enlazada Simple): 

			Cada nodo tiene un enlace al siguiente nodo en la secuencia. 

			Esta es la forma más común de linked list.


    	2. Doubly Linked List (Lista Enlazada Doble): 

    		Cada nodo tiene enlaces tanto al siguiente como al nodo anterior en la secuencia.

    		Esto permite recorrer la lista en ambas direcciones.


    	3. Circular Linked List (Lista Enlazada Circular): 

    		El último nodo de la lista tiene una referencia al primer nodo, creando un ciclo en la lista.


	Ejemplo de singly linked list: 

		```python

			class Nodo:
			    def __init__(self, valor):
			        self.valor = valor
			        self.siguiente = None

			class LinkedList:
			    def __init__(self):
			        self.cabeza = None

			    def agregar_elemento(self, valor):
			        nuevo_nodo = Nodo(valor)
			        if not self.cabeza:
			            self.cabeza = nuevo_nodo
			        else:
			            actual = self.cabeza
			            while actual.siguiente:
			                actual = actual.siguiente
			            actual.siguiente = nuevo_nodo

			    def imprimir_lista(self):
			        actual = self.cabeza
			        while actual:
			            print(actual.valor, end=" -> ")
			            actual = actual.siguiente
			        print("None")

			# Crear una linked list
			mi_lista = LinkedList()

			# Agregar elementos
			mi_lista.agregar_elemento(1)
			mi_lista.agregar_elemento(2)
			mi_lista.agregar_elemento(3)

			# Imprimir la lista
			mi_lista.imprimir_lista()

		```

		Salida (rust): 

		```	
			1 -> 2 -> 3 -> None

		```


	Casos de uso: 

		Implementación de Listas Dinámicas: 

			Las listas enlazadas son ideales para implementar listas dinámicas, donde el tamaño de la lista puede crecer o disminuir según sea necesario. 

			Esto contrasta con las listas estáticas, como las listas de Python, que tienen un tamaño fijo.


	    Inserción y Eliminación Eficiente: 

	    	Las listas enlazadas son eficientes para insertar y eliminar elementos en cualquier posición, ya que solo es necesario ajustar los punteros para mantener la estructura enlazada. 

	    	Esto es útil en aplicaciones donde se realizan inserciones y eliminaciones frecuentes.


	    Implementación de Pilas: 

	    	Las listas enlazadas se utilizan comúnmente para implementar pilas (stacks), una estructura de datos que sigue el principio de "último en entrar, primero en salir" (LIFO). 

	    	Las operaciones de apilamiento (push) y desapilamiento (pop) son rápidas en una lista enlazada.


	    Implementación de Colas: 

	    	Las listas enlazadas también se pueden utilizar para implementar colas (queues), una estructura de datos que sigue el principio de "primero en entrar, primero en salir" (FIFO). 

	    	Las operaciones de encolamiento (enqueue) y desencolamiento (dequeue) son eficientes en una lista enlazada.


	    Memoria Dinámica: 

	    	Las listas enlazadas permiten una asignación dinámica de memoria, lo que significa que los nodos de la lista pueden asignarse en tiempo de ejecución según sea necesario. 

	    	Esto es útil cuando el tamaño de los datos es desconocido de antemano.


	    Implementación de Estructuras de Datos Avanzadas: 

	    	Las listas enlazadas se utilizan como componentes en la implementación de estructuras de datos más complejas, como árboles, grafos y pilas dobles (double-ended queues).


	    Economía de Espacio: 

	    	En comparación con algunas estructuras de datos, como matrices, las listas enlazadas pueden ser más eficientes en términos de uso de memoria, ya que solo asignan memoria para los elementos que contienen datos.


	    Listas de Reproducción de Música o Videos: 

	    	Las listas enlazadas se pueden utilizar para crear listas de reproducción, donde cada nodo contiene información sobre una pista de música o un video y un enlace al siguiente elemento de la lista.


	    Historial de Navegación: 

	    	En navegadores web, las listas enlazadas se utilizan a menudo para implementar el historial de navegación, donde cada nodo representa una página web visitada y contiene enlaces al siguiente y al anterior.


	    Manipulación de Grandes Conjuntos de Datos: 

	    	Cuando se trabaja con grandes conjuntos de datos, las listas enlazadas pueden ofrecer ventajas en términos de eficiencia en la gestión de memoria y en la manipulación de datos, especialmente cuando se realizan operaciones frecuentes de inserción o eliminación.



|| HEAPS
	
	Estructura de datos que se utiliza para organizar y gestionar una colección de elementos de manera que el elemento más pequeño (en un "min heap") o el elemento más grande (en un "max heap") esté siempre en la parte superior del heap. 

	Los heaps son comunes en algoritmos de búsqueda, clasificación y priorización.

	En Python, puedes implementar heaps utilizando la biblioteca estándar llamada heapq, que proporciona funciones y métodos para trabajar con heaps, especialmente min heaps. 


	Min Heap con heapq:

		Un min heap es un heap en el que el elemento más pequeño se encuentra en la parte superior.

		```python

			//Importar la biblioteca heapq
			import heapq

			//Crear un heap vacio
			mi_heap = []

			//Agregar Elementos
			heapq.heappush(mi_heap, 5)
			heapq.heappush(mi_heap, 3)
			heapq.heappush(mi_heap, 7)

			//Obtener el elemento mas pequeno
			elemento_mas_pequeno = heapq.heappop(mi_heap)

		```

		El heap se mantiene automáticamente en un estado válido, por lo que siempre puedes obtener el elemento más pequeño con heappop().

	
	Max Heap con heapq:
		
		heapq se utiliza principalmente para min heaps, pero puedes emular un max heap al negar los valores que insertas y obtienes del heap. 

		```python

			mi_max_heap = []
			elementos = [5, 3, 7]

			for elemento in elementos:
		    	heapq.heappush(mi_max_heap, -elemento)

			elemento_mas_grande = -heapq.heappop(mi_max_heap)

		```

		Esto emula un max heap, donde el elemento más grande estará en la parte superior.

		En los heapq el elemento más pequeño (o más grande) esté siempre disponible en la parte superior. 


	Casos de uso: 

		Ordenar una Lista: 

			Un montículo se puede utilizar para ordenar una lista de elementos en orden ascendente o descendente de manera eficiente. 

			Esto se logra insertando todos los elementos en el montículo y luego extrayendo repetidamente el elemento principal hasta que el montículo esté vacío. 

			Este proceso se llama ordenación de montículos (heap sort).


	    Encontrar el Elemento Extremo: 

	    	Puedes utilizar un montículo para encontrar rápidamente el elemento más grande o más pequeño en una colección de elementos. 

	    	Esto es útil en aplicaciones como encontrar el mejor puntaje en un juego o el artículo más caro en una tienda en línea.


	    Implementar Colas de Prioridad: 

	    	Los montículos se utilizan comúnmente para implementar colas de prioridad, donde los elementos se ordenan según su prioridad y se extraen en orden de prioridad. 

	    	Esto es útil en algoritmos de búsqueda y grafos, así como en la planificación de tareas.


	    Encontrar los K Elementos Más Grandes o Pequeños: 

	    	Los montículos se pueden utilizar para encontrar los K elementos más grandes o más pequeños en una colección de elementos. 

	    	Esto es útil en análisis de datos y selección de elementos principales.


	    Programación Dinámica: 

	    	En algoritmos de programación dinámica, los montículos se utilizan para mantener un conjunto de estados posibles y seleccionar el mejor estado en función de ciertos criterios. 

	    	Esto es común en problemas de optimización.


	    Algoritmos de Grafos: 

	    	Los montículos son útiles en algoritmos de grafos como el algoritmo de Dijkstra y el algoritmo A*, donde se necesita seleccionar el próximo nodo óptimo para explorar.


	    Gestión de Memoria: 

	    	Los montículos se pueden utilizar para gestionar la memoria en tiempo de ejecución, asignando y liberando bloques de memoria según sea necesario.


	    Algoritmos de Búsqueda: 

	    	Los montículos se utilizan en algoritmos de búsqueda como el algoritmo de búsqueda A* para mantener un conjunto de nodos abiertos y seleccionar el siguiente nodo a explorar.


	    Tareas de Planificación: 

	    	En aplicaciones de planificación y programación, los montículos pueden ayudar a seleccionar tareas pendientes en función de su prioridad y restricciones.


	    Gestión de Colisiones: 

	    	En aplicaciones de bases de datos y estructuras de almacenamiento, los montículos pueden ayudar a gestionar colisiones y conflictos de forma eficiente.



|| STACKS
	
	Es una estructura de datos lineal que sigue el principio de "último en entrar, primero en salir" (LIFO, por sus siglas en inglés). 

	Esto significa que el último elemento agregado a la pila es el primero en ser eliminado. 

	Las pilas son útiles para llevar un registro de elementos en un orden específico y para realizar seguimiento de llamadas a funciones en la memoria del programa.
	

	Puedes implementar una pila de varias maneras:

	1. Usando una Lista:

		La forma más sencilla de implementar una pila en Python es utilizando una lista y las operaciones append() para agregar elementos y pop() para eliminar elementos del final de la lista (último en entrar, primero en salir). 

		```python

			# Crear una pila vacía
			pila = []

			# Agregar elementos a la pila
			pila.append(1)
			pila.append(2)
			pila.append(3)

			# Eliminar elementos de la pila (LIFO)
			elemento_eliminado = pila.pop()
			print(elemento_eliminado)  # Resultado: 3

		```


	2. Usando una Colección deque del módulo collections:

		La colección deque proporciona una implementación más eficiente de una pila en Python, ya que permite agregar y eliminar elementos tanto al principio como al final de la colección en tiempo constante.

		```python

			from collections import deque

			# Crear una pila vacía utilizando deque
			pila = deque()

			# Agregar elementos al principio de la pila
			pila.appendleft(1)
			pila.appendleft(2)
			pila.appendleft(3)

			# Eliminar elementos de la pila (LIFO)
			elemento_eliminado = pila.popleft()
			print(elemento_eliminado)  # Resultado: 3

		```


	3. Usando una Clase Personalizada:

		También puedes crear tu propia clase de pila personalizada si necesitas funciones y comportamientos adicionales. 

		```python

			class Pila:
			    def __init__(self):
			        self.items = []

			    def esta_vacia(self):
			        return len(self.items) == 0

			    def apilar(self, elemento):
			        self.items.append(elemento)

			    def desapilar(self):
			        if not self.esta_vacia():
			            return self.items.pop()
			        else:
			            return "La pila está vacía"

			# Usar la clase de pila personalizada
			mi_pila = Pila()
			mi_pila.apilar(1)
			mi_pila.apilar(2)
			mi_pila.apilar(3)

			elemento_eliminado = mi_pila.desapilar()
			print(elemento_eliminado)  # Resultado: 3

		```

	Casos de uso: 

		Gestión de Llamadas de Funciones: 

			En la ejecución de programas, las llamadas a funciones y los contextos de funciones se gestionan utilizando una pila. 

			Cuando una función se llama, su contexto se coloca en la pila y se retira cuando la función retorna. 

			Esto permite el seguimiento de las llamadas anidadas y la gestión de la memoria.


	    Navegación de Historial en Navegadores Web: 

	    	Los botones "Atrás" y "Adelante" en los navegadores web utilizan una pila para realizar un seguimiento de las páginas visitadas. 

	    	Cada vez que visitas una página, se agrega a la pila y se puede regresar o avanzar a través del historial.


	    Validación de Paréntesis y Corchetes: 

	    	Las pilas se utilizan para validar la correcta apertura y cierre de paréntesis, corchetes y llaves en expresiones matemáticas o código fuente. 

	    	Cuando se encuentra un símbolo de apertura, se agrega a la pila, y cuando se encuentra un símbolo de cierre, se verifica si coincide con el símbolo en la cima de la pila.


	    Implementación de Undo/Redo: 

	    	En aplicaciones de software, como editores de texto o programas de diseño, las pilas se utilizan para realizar un seguimiento de las acciones realizadas por el usuario. 

	    	Cada acción se almacena en una pila de "deshacer" (undo) y se puede revertir utilizando una pila de "rehacer" (redo).


	    Recorrido de Árboles y Grafos: 

	    	En algoritmos de recorrido de árboles y grafos, como la búsqueda en profundidad (DFS, Depth-First Search), se utilizan pilas para mantener un seguimiento de los nodos por visitar. 

	    	Los nodos se colocan y retiran de la pila a medida que se exploran.


	    Implementación de Algoritmos de Resolución: 

	    	En algoritmos de resolución de problemas, como la resolución de laberintos o la búsqueda de caminos óptimos, las pilas se utilizan para mantener un seguimiento de las ubicaciones o estados por explorar.


	    Gestión de Historial en Aplicaciones: 

	    	Las pilas se utilizan en aplicaciones como reproductores de música y visores de imágenes para realizar un seguimiento de las canciones o imágenes anteriores. 

	    	Los botones "Anterior" y "Siguiente" utilizan pilas para esta funcionalidad.


	    Evaluar Expresiones Postfijas (Notación Polaca Inversa): 

	    	En matemáticas y ciencias de la computación, las pilas se utilizan para evaluar expresiones en notación polaca inversa (postfix), que no requieren paréntesis ni precedencia de operadores.


	    Gestión de Transacciones en Bases de Datos: 

	    	En bases de datos, las pilas se utilizan para mantener un seguimiento de las transacciones y deshacer cambios en caso de error o reversión.


	    Simulación de Procesos: 

	    	En simulaciones computacionales, las pilas se utilizan para llevar un registro de eventos y estados a medida que se procesan y deshacen.



|| QUEUES 

	Es una estructura de datos lineal que sigue el principio de "primero en entrar, primero en salir" (FIFO, por sus siglas en inglés). 

	Esto significa que el primer elemento en ser agregado a la cola es el primero en ser eliminado. 

	Las colas son útiles para gestionar elementos en un orden específico, como cuando se necesita procesar elementos en el orden en el que fueron recibidos.


	Puedes implementar una cola en Python de varias maneras:

	1. Usando una Lista:

		La forma más simple de implementar una cola en Python es utilizando una lista y las operaciones append() para agregar elementos al final de la lista y pop(0) para eliminar elementos del principio de la lista (primero en entrar, primero en salir). 

		Sin embargo, esta implementación no es eficiente para colas grandes ya que pop(0) tiene un costo de tiempo lineal. 

		```python

			# Crear una cola vacía
			cola = []

			# Agregar elementos a la cola
			cola.append(1)
			cola.append(2)
			cola.append(3)

			# Eliminar elementos de la cola (FIFO)
			elemento_eliminado = cola.pop(0)
			print(elemento_eliminado)  # Resultado: 1

		```


	2. Usando una Colección deque del módulo collections:

		La colección deque proporciona una implementación más eficiente de una cola en Python, ya que permite agregar y eliminar elementos tanto al final como al principio de la colección en tiempo constante. 

		```python

			from collections import deque

			# Crear una cola vacía utilizando deque
			cola = deque()

			# Agregar elementos al final de la cola
			cola.append(1)
			cola.append(2)
			cola.append(3)

			# Eliminar elementos de la cola (FIFO)
			elemento_eliminado = cola.popleft()
			print(elemento_eliminado)  # Resultado: 1

		```


	3. Usando una Clase Personalizada:

		También puedes crear tu propia clase de cola personalizada si necesitas funciones y comportamientos adicionales.

		```python

			class Cola:
			    def __init__(self):
			        self.items = []

			    def esta_vacia(self):
			        return len(self.items) == 0

			    def encolar(self, elemento):
			        self.items.append(elemento)

			    def desencolar(self):
			        if not self.esta_vacia():
			            return self.items.pop(0)
			        else:
			            return "La cola está vacía"

			# Usar la clase de cola personalizada
			mi_cola = Cola()
			mi_cola.encolar(1)
			mi_cola.encolar(2)
			mi_cola.encolar(3)

			elemento_eliminado = mi_cola.desencolar()
			print(elemento_eliminado)  # Resultado: 1

		```	


	Casos de uso: 

	    Procesamiento de Tareas en Lote: 

	    	Las colas se utilizan en aplicaciones donde es importante procesar tareas en un orden específico y de manera secuencial. 

	    	Por ejemplo, en una impresora, las impresiones se agregan a una cola y se imprimen en el orden en que se enviaron.


	    Gestión de Solicitudes de Servidor: 

	    	En aplicaciones de servidor, como servidores web, las solicitudes de clientes se colocan en una cola para que se procesen en el orden en que se recibieron. 

	    	Esto garantiza que las solicitudes se manejen de manera justa y en secuencia.


	    Búfer de Datos: 

	    	Las colas se utilizan para almacenar datos antes de que se procesen. 

	    	Por ejemplo, en la transmisión de datos por streaming, los datos se almacenan en una cola antes de ser enviados o procesados.


	    Control de Flujo de Datos: 

	    	En sistemas de control de flujo de datos, las colas se utilizan para administrar el flujo de datos entre componentes. 

	    	Esto es común en aplicaciones de procesamiento de señales y comunicaciones.


	    Gestión de Tareas Asíncronas: 

	    	En aplicaciones que manejan tareas asíncronas, como procesamiento por lotes o procesamiento en segundo plano, las colas se utilizan para mantener un registro de las tareas pendientes y en progreso.


	    Búsquedas en Amplitud en Grafos: 	
	    	Las colas son esenciales en algoritmos de búsqueda en amplitud (BFS, Breadth-First Search) para recorrer grafos de manera eficiente. 

	    	Los nodos se agregan a la cola y se exploran en orden.


	    Cola de Espera de Clientes: 

	    	En sistemas de atención al cliente o soporte técnico, las colas se utilizan para administrar las solicitudes de los clientes en espera.

	    	Las solicitudes se atienden en el orden en que llegaron.


	    Simulación de Líneas de Espera: 

	    	En simulaciones de sistemas, como simulaciones de líneas de espera en tiendas o bancos, las colas se utilizan para modelar el comportamiento de los clientes y el tiempo que pasan esperando en la fila.


	    Gestión de Mensajes en Cola: 

	    	En sistemas de mensajería, como colas de mensajes en aplicaciones de correo electrónico o sistemas de mensajería instantánea, las colas se utilizan para almacenar y entregar mensajes de manera secuencial.


	    Almacenamiento Temporal: 

	    	Las colas se utilizan como almacenamiento temporal en diversas aplicaciones, como la recepción de datos en tiempo real antes de que se procesen, o para administrar solicitudes de recursos compartidos en sistemas multiproceso.



|| HASH TABLES
	
	Es una estructura de datos que permite almacenar y recuperar datos de manera eficiente utilizando una función de hash. 

	Esta función de hash toma un valor (llave o clave) y lo convierte en un índice en la tabla. 

	Cada índice se asocia con un bucket (casillero o celda), que puede contener múltiples valores o un solo valor, dependiendo de cómo se manejen las colisiones.

	Las hash tables son eficientes para buscar, insertar y eliminar datos, ya que proporcionan acceso directo a los valores mediante su clave en tiempo constante, en promedio. 

	Esto significa que el tiempo requerido para realizar estas operaciones no depende del número de elementos en la tabla.

	Se utilizan en una variedad de tareas, como el almacenamiento de configuraciones, datos estructurados y más.

	En Python, puedes implementar una hash table utilizando un diccionario (dict), que es una estructura de datos incorporada que utiliza una tabla de dispersión subyacente para almacenar pares clave-valor.


	```python

		# Crear un diccionario vacío
		mi_diccionario = {}

		# Agregar elementos al diccionario
		mi_diccionario['nombre'] = 'Juan'
		mi_diccionario['edad'] = 30
		mi_diccionario['ciudad'] = 'Nueva York'

		# Acceder a elementos por clave
		print(mi_diccionario['nombre'])  # Resultado: 'Juan'

		# Modificar un elemento
		mi_diccionario['edad'] = 31

		# Eliminar un elemento
		del mi_diccionario['ciudad']

		# Verificar si una clave existe en el diccionario
		if 'ciudad' in mi_diccionario:
		    print('La clave "ciudad" existe en el diccionario')
		else:
		    print('La clave "ciudad" no existe en el diccionario')

		# Imprimir el diccionario completo
		print(mi_diccionario)

	```

	Salida (perl): 

	```python

		Juan
		La clave "ciudad" no existe en el diccionario
		{'nombre': 'Juan', 'edad': 31}

	```


	Casos de uso: 

		Búsqueda Rápida: 

			Las tablas hash se utilizan para realizar búsquedas eficientes en grandes conjuntos de datos. 

			En lugar de recorrer todos los elementos, el valor deseado se busca mediante su clave correspondiente, lo que proporciona un acceso rápido a la información.


	    Almacenamiento de Datos: 

	    	Las tablas hash se utilizan para almacenar datos de manera eficiente, ya que permiten acceder rápidamente a los datos a través de sus claves. 

	    	Esto es especialmente útil en aplicaciones donde se necesita acceso rápido a información, como bases de datos o cachés de memoria.


	    Diccionarios en Python: 

	    	En Python, los diccionarios son implementaciones de tablas hash. 

	    	Se utilizan ampliamente para mapear claves a valores y son esenciales en muchas aplicaciones, desde la gestión de configuraciones hasta la recopilación de estadísticas.


	    Verificación de Contraseñas: 

	    	En aplicaciones de seguridad, como la autenticación de usuarios, las tablas hash se utilizan para almacenar contraseñas de manera segura.

	    	En lugar de almacenar las contraseñas en texto claro, se almacena su hash, lo que dificulta la recuperación de la contraseña real por parte de posibles atacantes.


	    Detección de Duplicados: 

	    	Las tablas hash se pueden utilizar para detectar duplicados en conjuntos de datos. 

	    	A medida que se agregan elementos a la tabla, se verifica si ya existen, lo que permite mantener una lista de elementos únicos.


	    Conteo de Elementos: 

	    	En aplicaciones donde es necesario contar la frecuencia de elementos, como el conteo de palabras en un documento, las tablas hash se utilizan para realizar un seguimiento eficiente de las ocurrencias de cada elemento.


	    Almacenamiento en Caché: 

	    	Las tablas hash se utilizan en la implementación de cachés de memoria. 

	    	Los datos que se acceden con frecuencia se almacenan en una tabla hash en lugar de recuperarse repetidamente desde una fuente de datos más lenta, como una base de datos.


	    Enrutamiento de Redes: 

	    	En enrutadores de redes, las tablas hash se utilizan para determinar cómo dirigir los paquetes de datos a través de la red. 

	    	La dirección de destino se utiliza como clave para buscar la ruta adecuada en la tabla hash de enrutamiento.


	    Gestión de Colisiones: 

	    	Las tablas hash también se utilizan para gestionar colisiones, que ocurren cuando dos claves generan el mismo valor hash. 

	    	Se utilizan técnicas como la resolución de colisiones por encadenamiento o el uso de árboles binarios para manejar estas situaciones.


	    Algoritmos de Búsqueda Rápida: 

	    	En algoritmos de búsqueda rápida, como el algoritmo de búsqueda de Google, las tablas hash se utilizan para indexar y recuperar resultados de búsqueda en tiempo real.



|| BINARY SEARCH TREES 
	
	Es una estructura de datos jerárquica que se utiliza para organizar y almacenar datos de forma eficiente. La característica principal de un BST es que cada nodo tiene hasta dos hijos: un hijo izquierdo y un hijo derecho. 

	Además, la propiedad fundamental de un BST es que los nodos se organizan de manera que para cualquier nodo:

   		Todos los nodos en el subárbol izquierdo tienen valores menores que el nodo raíz.

    	Todos los nodos en el subárbol derecho tienen valores mayores que el nodo raíz.

	Esta propiedad hace que la búsqueda, inserción y eliminación de elementos en un BST sea muy eficiente, ya que reduce el número de comparaciones necesarias para encontrar un elemento en comparación con una búsqueda secuencial.

	En Python, puedes implementar un BST mediante la creación de una clase Nodo que tiene referencias a sus hijos izquierdo y derecho, y luego una clase BST que maneja la inserción, búsqueda y eliminación de nodos en el árbol.	

	```python

		class Nodo:
		    def __init__(self, valor):
		        self.valor = valor
		        self.izquierdo = None
		        self.derecho = None

		class BST:
		    def __init__(self):
		        self.raiz = None

		    def insertar(self, valor):
		        self.raiz = self._insertar_recursivamente(self.raiz, valor)

		    def _insertar_recursivamente(self, nodo_actual, valor):
		        if nodo_actual is None:
		            return Nodo(valor)
		        if valor < nodo_actual.valor:
		            nodo_actual.izquierdo = self._insertar_recursivamente(nodo_actual.izquierdo, valor)
		        elif valor > nodo_actual.valor:
		            nodo_actual.derecho = self._insertar_recursivamente(nodo_actual.derecho, valor)
		        return nodo_actual

		    def buscar(self, valor):
		        return self._buscar_recursivamente(self.raiz, valor)

		    def _buscar_recursivamente(self, nodo_actual, valor):
		        if nodo_actual is None or nodo_actual.valor == valor:
		            return nodo_actual
		        if valor < nodo_actual.valor:
		            return self._buscar_recursivamente(nodo_actual.izquierdo, valor)
		        return self._buscar_recursivamente(nodo_actual.derecho, valor)

		# Crear un BST
		mi_bst = BST()

		# Insertar elementos
		mi_bst.insertar(50)
		mi_bst.insertar(30)
		mi_bst.insertar(70)
		mi_bst.insertar(20)
		mi_bst.insertar(40)

		# Buscar elementos
		print(mi_bst.buscar(30))  # Resultado: <__main__.Nodo object at 0x...>

	```

	Es importante destacar que el tiempo de búsqueda en un BST es en promedio logarítmico (O(log n)), lo que lo hace eficiente para conjuntos de datos grandes. 

	Sin embargo, si el árbol no está equilibrado, el tiempo de búsqueda podría ser lineal en el peor caso (O(n)). 

	Por lo tanto, mantener el equilibrio del árbol es crucial para un rendimiento óptimo, y existen varias variantes de BST, como el AVL tree y el Red-Black tree, que se diseñaron para garantizar que el árbol permanezca equilibrado.


	Casos de uso: 

		Búsqueda Eficiente:

		    Un uso fundamental de los árboles de búsqueda binaria es para la búsqueda eficiente de elementos. 

		    Dado que los elementos en un árbol de búsqueda binaria se organizan de manera que los elementos más pequeños están a la izquierda y los elementos más grandes están a la derecha, puedes buscar un elemento en tiempo logarítmico (O(log n)), lo que es mucho más rápido que una búsqueda lineal en una lista no ordenada.


		Inserción y Eliminación Eficientes:

		    Los árboles de búsqueda binaria también son eficientes para la inserción y eliminación de elementos.

		    Cuando insertas un nuevo elemento, el árbol se reorganiza automáticamente para mantener su propiedad de búsqueda binaria. 

		    Lo mismo ocurre cuando eliminas un elemento. 

		    Esto permite una inserción y eliminación en tiempo logarítmico en promedio.


		Ordenación In-Place:

		    Los árboles de búsqueda binaria se pueden utilizar para ordenar una lista de elementos en lugar de utilizar algoritmos de ordenación como Quicksort o Mergesort. 

		    Esto se logra insertando los elementos en el árbol y luego recorriéndolo en orden. 

		    La ordenación in situ es útil cuando deseas ordenar una gran cantidad de datos sin utilizar memoria adicional.


		Mantener un Conjunto Ordenado:

		    Los árboles de búsqueda binaria se pueden utilizar para mantener un conjunto de elementos ordenados de manera eficiente. 

		    Esto es útil en aplicaciones donde necesitas mantener una lista ordenada y realizar operaciones como agregar elementos y verificar si un elemento está presente.


		Estructura de Datos para Búsqueda Rápida:

		    Los árboles de búsqueda binaria se utilizan en estructuras de datos más complejas como los "Binary Search Tree Sets" y los "Binary Search Tree Maps".

		    Estas estructuras de datos aprovechan las propiedades de búsqueda rápida de los árboles de búsqueda binaria para implementar conjuntos ordenados y diccionarios (mapas) eficientes.


		Algoritmos de Gráficos:

		    Los árboles de búsqueda binaria también se utilizan en algoritmos de gráficos, como el algoritmo de Kruskal para encontrar el árbol de expansión mínimo en un grafo ponderado. 

		    En este contexto, los árboles de búsqueda binaria se utilizan para mantener y actualizar conjuntos de vértices de manera eficiente.


		Optimización de Búsqueda en Bases de Datos:

		    En bases de datos, los índices basados en árboles de búsqueda binaria se utilizan para acelerar las búsquedas.

		    Estos índices permiten una búsqueda rápida en grandes conjuntos de datos almacenados en discos duros u otros medios de almacenamiento.


		Árboles AVL y Árboles Rojo-Negro para Mantener el Balance:

		    En aplicaciones donde es importante mantener un árbol balanceado, se utilizan variantes de los árboles de búsqueda binaria, como los árboles AVL y los árboles rojo-negro. 

		    Estos árboles garantizan un equilibrio que permite un rendimiento de búsqueda predecible





|| SORTING ALGORITHMS
	
	Son algoritmos que organizan un conjunto de elementos en un orden específico, como orden ascendente o descendente. 

	La ordenación de datos es una operación fundamental en la informática y se utiliza en una variedad de aplicaciones, desde la búsqueda eficiente en bases de datos hasta la visualización de datos en gráficos. 

	En Python, hay varios algoritmos de ordenamiento disponibles, cada uno con sus propias características y eficiencia.


	1. Bubble Sort (Ordenamiento de Burbuja): 

		Este es uno de los algoritmos de ordenamiento más simples. 

		Funciona comparando pares de elementos adyacentes y, si están en el orden incorrecto, los intercambia. 

		Este proceso se repite hasta que no se requieran más intercambios. 

		El Bubble Sort no es eficiente para grandes conjuntos de datos y tiene una complejidad de tiempo de O(n^2) en el peor caso.


    2. Insertion Sort (Ordenamiento por Inserción): 

    	En este algoritmo, los elementos se consideran uno por uno e se insertan en su posición correcta entre los elementos ya ordenados. 

    	El Insertion Sort es eficiente para conjuntos de datos pequeños y casi ordenados, pero tiene una complejidad de tiempo de O(n^2) en el peor caso.


    3. Selection Sort (Ordenamiento por Selección): 

    	Este algoritmo busca el elemento más pequeño en la lista y lo coloca en la posición correcta.

    	Luego, busca el siguiente elemento más pequeño y lo coloca en la siguiente posición correcta, y así sucesivamente. 

    	El Selection Sort también tiene una complejidad de tiempo de O(n^2) en el peor caso.


    4. Merge Sort (Ordenamiento por Mezcla): 

    	El Merge Sort es un algoritmo de ordenamiento divide y conquista.

    	Divide la lista en sublistas más pequeñas, las ordena y luego las fusiona para obtener una lista ordenada. 

    	Es más eficiente que los algoritmos anteriores y tiene una complejidad de tiempo de O(n log n) en el peor caso.


    5. Quick Sort (Ordenamiento Rápido): 

    	El Quick Sort también es un algoritmo divide y conquista. 

    	Divide la lista en dos sublistas, una con elementos menores que un pivote y otra con elementos mayores. 

    	Luego, ordena las sublistas y las combina. 

    	El Quick Sort es muy eficiente y tiene una complejidad de tiempo promedio de O(n log n) en el peor caso.


    6. Heap Sort (Ordenamiento por Montículo): 

    	El Heap Sort utiliza una estructura de datos llamada montículo (heap) para organizar los elementos. 

    	Convierte la lista en un montículo, luego extrae repetidamente el elemento máximo (o mínimo) y lo coloca en la lista ordenada. 

    	El Heap Sort tiene una complejidad de tiempo de O(n log n) en el peor caso.


    7. Timsort: 

    	Timsort es un algoritmo de ordenamiento híbrido que combina el Merge Sort y el Insertion Sort. 

    	Está diseñado para aprovechar las características de los datos del mundo real y es el algoritmo de ordenamiento predeterminado en Python.


    En Python, puedes utilizar la función sorted() para ordenar una lista de elementos utilizando el algoritmo Timsort. 

    También puedes implementar estos algoritmos manualmente si deseas estudiar cómo funcionan o si necesitas una implementación personalizada para tu caso específico.

	Por lo general, el algoritmo de ordenamiento que elijas dependerá de tus necesidades específicas, el tamaño de los datos a ordenar y el rendimiento deseado.


	Casos de uso: 

		Ordenar Listas y Secuencias: 

			El caso de uso más común para los algoritmos de ordenamiento es ordenar listas o secuencias de elementos en un orden específico, ya sea ascendente o descendente. 

			Esto es útil en una amplia variedad de aplicaciones, como ordenar nombres de usuarios, números, productos, etc.


	    Búsqueda Eficiente: 

	    	Los datos ordenados son más fáciles de buscar. 

	    	Cuando tienes una lista ordenada, puedes utilizar algoritmos de búsqueda binaria para encontrar elementos rápidamente, ya que reduces a la mitad la cantidad de elementos a considerar en cada paso.


	    Unión de Conjuntos: 

	    	Al ordenar dos conjuntos de elementos, puedes unirlos eficientemente eliminando duplicados y manteniendo solo un conjunto de elementos únicos. 

	    	Esto es útil en operaciones de conjuntos matemáticos.


	    Clasificación de Datos: 

	    	Los algoritmos de ordenamiento se utilizan en aplicaciones que requieren clasificar y organizar datos en categorías o clases, como la clasificación de correos electrónicos en carpetas.


	    Aplicaciones de Bases de Datos: 

	    	En sistemas de bases de datos, los algoritmos de ordenamiento son esenciales para organizar datos en índices, lo que permite un acceso rápido y eficiente a los registros.


	    Algoritmos de Búsqueda y Grafos: 

	    	Los algoritmos de ordenamiento a menudo se utilizan en algoritmos de búsqueda y grafos para ordenar listas de nodos o aristas en función de ciertos criterios, como el costo o la prioridad.


	    Planificación y Programación de Tareas: 

	    	En aplicaciones de planificación de tareas, como programación de proyectos o gestión de recursos, se utilizan algoritmos de ordenamiento para organizar tareas en función de su tiempo de inicio, duración, prioridad, etc.


	    Operaciones de Recolección de Datos: 

	    	Los algoritmos de ordenamiento son útiles en operaciones de recolección de datos, como seleccionar los mejores resultados en una búsqueda de texto o filtrar datos en una tabla.


	    Estadísticas y Análisis: 

	    	En análisis de datos y estadísticas, los datos a menudo se organizan y ordenan antes de realizar cálculos para facilitar la interpretación y el procesamiento.


	    Implementación de Estructuras de Datos: 

	    	Los algoritmos de ordenamiento se utilizan para implementar estructuras de datos como árboles de búsqueda binaria y montículos (heaps) que requieren datos ordenados para funcionar correctamente.



|| ITERATORS
	
	Se utiliza para recorrer secuencias de datos, como listas, tuplas, diccionarios y más.
	
	Es un objeto que representa una secuencia de datos. 

	Permite el acceso secuencial a los elementos de esa secuencia sin exponer los detalles de implementación subyacentes. 

	En otras palabras, un iterador proporciona una forma de recorrer los elementos de una colección de datos uno por uno sin tener que conocer la estructura interna de la colección.


	Características Clave de los Iteradores:

    	Métodos Principales: 

    		Los iteradores en Python deben implementar dos métodos principales:

        	__iter__(): 

        		Devuelve el propio objeto iterador. 

        		Esto permite que el iterador sea iterable, lo que significa que se puede utilizar en un bucle for.


       		__next__(): 

       			Devuelve el próximo elemento en la secuencia. 

       			Cuando no hay más elementos, lanza la excepción StopIteration para indicar el final de la secuencia.


    	Bucles for: 

    		Los iteradores son ampliamente utilizados en bucles for para recorrer colecciones de datos. 

    		Python maneja automáticamente la llamada a __iter__() y __next__() cuando se utiliza un bucle for.


    Ejemplo: 

    	```python

    		class Cuadrados:
			    def __init__(self, n):
			        self.n = n
			        self.current = 0

			    def __iter__(self):
			        return self

			    def __next__(self):
			        if self.current < self.n:
			            result = self.current ** 2
			            self.current += 1
			            return result
			        else:
			            raise StopIteration

			# Uso del iterador en un bucle for
			cuadrados_iter = Cuadrados(5)
			for cuadrado in cuadrados_iter:
			    print(cuadrado)

    	```

    	La clase Cuadrados es un iterador personalizado que genera los cuadrados de los números del 0 al n-1. 

    	Implementa los métodos __iter__() y __next__() para permitir la iteración.

	
	Características: 

		Eficiencia: 

			Los iteradores permiten el acceso a elementos de una secuencia uno por uno, lo que puede ser más eficiente en términos de memoria y velocidad que cargar todos los elementos en la memoria al mismo tiempo.


		Abstracción: 

			Los iteradores ocultan los detalles de la implementación subyacente de una colección, lo que hace que el código sea más limpio y fácil de entender.


		Compatibilidad con Bucles for: 	

			Los iteradores son la base de los bucles for en Python, lo que facilita el recorrido de colecciones de datos


	Iterador vs bucle for: 

		Sintaxis: 

			Los iteradores requieren llamadas explícitas a las funciones iter() y next(), mientras que los bucles for utilizan una sintaxis más simple y legible "for elemento in iterable:"


	    Uso: 

	    	Los bucles for son más comunes y más fáciles de usar cuando simplemente deseas recorrer una secuencia. 

	    	Los iteradores son útiles cuando necesitas un control más granular sobre la iteración o cuando trabajas con secuencias muy grandes.


	    Memoria: 

	    	Los iteradores son más eficientes en cuanto a la memoria, ya que no cargan todos los elementos en la memoria al mismo tiempo. 

	    	Los bucles for, en cambio, requieren que todos los elementos estén disponibles en la secuencia desde el principio.


	    Los iteradores y los bucles for son herramientas para la iteración en Python. 

	    Los bucles for son más simples y adecuados para la mayoría de los casos de iteración, mientras que los iteradores proporcionan un control más granular y son más eficientes en cuanto a la memoria.

	    La elección entre ellos depende de tus necesidades específicas en un programa.



|| RegEx

	las expresiones regulares, comúnmente conocidas como "RegEx" o "regex", son patrones de búsqueda y manipulación de cadenas de texto. 

	En Python, puedes utilizar el módulo re para trabajar con expresiones regulares.

	Conceptos claves: 

		Patrones de Búsqueda:

    		Las expresiones regulares se utilizan para definir patrones de búsqueda en cadenas de texto.

    		Estos patrones pueden incluir caracteres literales (como letras y números) y metacaracteres especiales que tienen significados especiales en RegEx.


		Metacaracteres:

			. (punto): Coincide con cualquier carácter, excepto una nueva línea.

			*: Coincide con cero o más repeticiones del carácter o patrón anterior.

			+: Coincide con una o más repeticiones del carácter o patrón anterior.

			?: Coincide con cero o una repetición del carácter o patrón anterior.

			| (barra vertical): Se utiliza para alternar entre varias opciones.

			[]: Define un conjunto de caracteres permitidos.

			(): Agrupa caracteres para aplicar operadores a grupos de caracteres.


		3. Funciones Principales del Módulo re:

			El módulo re en Python proporciona varias funciones para trabajar con expresiones regulares. 

			re.search(pattern, string): 

				Busca el patrón en toda la cadena y devuelve el primer resultado encontrado.


			re.match(pattern, string): 

				Comprueba si el patrón coincide con el inicio de la cadena.


			re.findall(pattern, string): 

				Encuentra todas las ocurrencias del patrón en la cadena y devuelve una lista.


			re.finditer(pattern, string):

				Encuentra todas las ocurrencias del patrón en la cadena y devuelve un iterador.


			re.sub(pattern, replacement, string): 

				Reemplaza todas las ocurrencias del patrón con la cadena de reemplazo.


			re.split(pattern, string): 

				Divide la cadena en una lista utilizando el patrón como delimitador.


	Ejemplo: 

		```python

			import re

			texto = "Hola, mi número de teléfono es 123-456-7890."

			# Buscar un número de teléfono en el texto
			patron = r'\d{3}-\d{3}-\d{4}'  # Expresión regular para números de teléfono
			resultado = re.search(patron, texto)

			if resultado:
			    print("Número de teléfono encontrado:", resultado.group())
			else:
			    print("Número de teléfono no encontrado.")

		```

		Utilizamos una expresión regular para buscar un número de teléfono en el texto. 

		El patrón \d{3}-\d{3}-\d{4} coincide con números de teléfono en el formato XXX-XXX-XXXX.


	Importante: 

	    Las expresiones regulares pueden volverse muy complejas, y es importante comprender bien los metacaracteres y patrones antes de utilizarlos en aplicaciones críticas.

    	Puedes usar herramientas en línea, como Regex101 o RegExr, para probar y depurar expresiones regulares.

    	La "r" antes de la cadena de patrón (por ejemplo, r'\d{3}-\d{3}-\d{4}') indica una cadena cruda (raw string) en Python, lo que evita que las barras invertidas escapen de los caracteres. 

    	Esto es útil cuando trabajas con expresiones regulares.


    Casos de uso: 

    	Validación de Formularios: 

    		Puedes utilizar expresiones regulares para validar entradas de formularios, como direcciones de correo electrónico, números de teléfono, códigos postales, etc. 

    		Por ejemplo, para asegurarte de que un correo electrónico tenga el formato correcto.


	    Búsqueda de Patrones en Texto: 

	    	Las expresiones regulares son útiles para buscar patrones específicos en documentos de texto, registros de log, archivos de registro, etc. 

	    	Por ejemplo, buscar direcciones IP en un archivo de registro.


	    Extracción de Datos: 	

	    	Puedes usar expresiones regulares para extraer información específica de un texto. 

	    	Esto es común en el análisis de registros y la minería de texto.


	    Reemplazo de Texto: 

	    	Las expresiones regulares se utilizan para reemplazar texto en un documento. 

	    	Esto es útil para limpiar datos, realizar sustituciones específicas o cambiar el formato del texto.


	    Análisis de Texto: 

	    	Las expresiones regulares pueden ayudarte a analizar texto para identificar patrones, como menciones de usuarios en redes sociales, hashtags, enlaces web, etc.


	    Validación de Contraseñas: 

	    	Puedes usar expresiones regulares para establecer reglas de validación para contraseñas, como la longitud mínima, la presencia de caracteres especiales, etc.


	    Web Scrapping: 

	    	Al extraer información de sitios web, las expresiones regulares se pueden utilizar para buscar y extraer datos específicos de las páginas web.


	    Tokenización: 	

	    	En el procesamiento de lenguaje natural (NLP), las expresiones regulares se utilizan para dividir el texto en tokens (palabras, frases, etc.) para su posterior análisis.


	    Validación de Código Fuente: 

	    	En algunos casos, se utilizan expresiones regulares para analizar y validar el código fuente de programas, especialmente en lenguajes de marcado como HTML y XML.


	    Análisis de Logs: 

	    	En el análisis de registros (logs), las expresiones regulares se utilizan para identificar y extraer información relevante de registros de eventos.


	    Procesamiento de Datos: 

	    	Las expresiones regulares son esenciales en la manipulación de datos en lenguajes de programación como Python. 

	    	Se utilizan para dividir y procesar cadenas de texto complejas.


	    Validación de Datos: 

	    	Se pueden utilizar para validar datos de entrada en una aplicación, como números de tarjeta de crédito, números de seguridad social, etc.



|| DECORATORS 

	Se utiliza para modificar o extender el comportamiento de funciones o métodos en tiempo de ejecución sin cambiar su código fuente. 

	Los decoradores se utilizan comúnmente para realizar tareas como la autenticación, el registro de tiempo de ejecución, la validación de entrada y muchas otras funcionalidades. 


	Conceptos claves: 

		Funciones de Orden Superior: 

			En Python, las funciones son objetos de primera clase, lo que significa que pueden ser pasadas como argumentos a otras funciones y devueltas como resultados de funciones. 

			Esto es fundamental para comprender cómo funcionan los decoradores.


		Sintaxis de Decorador: 

			Los decoradores se definen utilizando una sintaxis especial con el símbolo @ antes de la función que se utilizará como decorador. 

			Por ejemplo:

			```python

				@decorador
				def funcion_a_decorar():
    				# Código de la función

			```


		Funciones Decoradoras: 

			Un decorador es en sí mismo una función que toma otra función como argumento y devuelve una nueva función que puede extender o modificar el comportamiento de la función original.

			Ejemplo simple de un decorador que registra el tiempo de ejecución de una función:

			```python

				import time

				def calcular_tiempo(funcion):
				    def wrapper(*args, **kwargs):
				        inicio = time.time()
				        resultado = funcion(*args, **kwargs)
				        fin = time.time()
				        print(f"Tiempo de ejecución de {funcion.__name__}: {fin - inicio} segundos")
				        return resultado
				    return wrapper

				# Uso del decorador para medir el tiempo de ejecución
				@calcular_tiempo
				def operacion_lenta():
				    time.sleep(2)

				operacion_lenta()

			```

			En este ejemplo, calcular_tiempo es un decorador que envuelve la función operacion_lenta. 

			Cuando llamamos a operacion_lenta(), en realidad estamos llamando a la función decorada wrapper, que registra el tiempo antes y después de llamar a operacion_lenta().


	Características: 

		Reutilización de Código: 

			Los decoradores permiten encapsular funcionalidades comunes y reutilizarlas en múltiples funciones o métodos sin duplicar código.


    	Separación de Responsabilidades: 

    		Los decoradores permiten separar preocupaciones, lo que hace que el código sea más claro y modular. 

    		Cada decorador puede encargarse de una tarea específica.


    	Facilita la Lectura: 

    		Los decoradores pueden mejorar la legibilidad del código al eliminar detalles de implementación no esenciales de las funciones.


	   	Registro de Log:

	        Un decorador puede utilizarse para registrar información sobre cuándo se llama una función y con qué argumentos.


	    Autenticación y Autorización:

	        Los decoradores se pueden emplear para verificar si un usuario tiene permisos para acceder a una ruta o función en una aplicación web.


	    Validación de Entrada:

	        Puedes crear decoradores que verifiquen que los argumentos de entrada cumplen con ciertos criterios antes de que una función se ejecute.


	    Medición del Tiempo de Ejecución:

	        Los decoradores pueden calcular y registrar el tiempo que lleva ejecutar una función.


	    Caché de Resultados:

	        Puedes crear un decorador que almacene en caché los resultados de una función para evitar calcularlos nuevamente si se le proporcionan los mismos argumentos.


	    Transformación de Datos:

	        Un decorador puede transformar los datos de entrada o salida de una función según sea necesario.


	    Enrutamiento en Aplicaciones Web:

	        En un framework web como Flask, los decoradores se utilizan para asignar rutas de URL a funciones controladoras.


	    Administración de Sesiones:

	        Puedes usar decoradores para administrar sesiones de usuario en una aplicación web.


	    Compresión de Respuestas:

	        En aplicaciones web, los decoradores pueden comprimir las respuestas antes de enviarlas al cliente.


	    Validación de Formularios:

	        Un decorador puede verificar que los datos enviados a través de un formulario en una aplicación web sean válidos.


	    Seguridad:

	        Los decoradores se pueden utilizar para aplicar medidas de seguridad, como la protección contra ataques CSRF (Cross-Site Request Forgery).


	    Manejo de Errores:

	        Un decorador puede capturar excepciones y manejarlas de una manera específica, por ejemplo, registrando errores.


	    Internacionalización (i18n):

	        Puedes crear un decorador que traduzca el texto devuelto por una función a diferentes idiomas según las preferencias del usuario.


	    Comprobación de Tipos:

	        Los decoradores pueden verificar que los argumentos de una función sean del tipo esperado.


	    Configuración Dinámica:

	        Los decoradores pueden modificar la configuración de una función o clase en tiempo de ejecución.


	    Control de Acceso:

	        Se pueden usar decoradores para restringir el acceso a ciertas partes de una aplicación o sistema.



|| MÓDULOS 
	
	Son archivos que contienen definiciones y declaraciones de Python. 

	Estos archivos pueden contener funciones, clases y variables que pueden ser reutilizados en otros programas o scripts. 

	Los módulos permiten organizar y estructurar el código de manera más eficiente y facilitan la reutilización de código.


	Características:

		Archivos de Código Fuente: 

			Los módulos son archivos de código fuente con extensión .py. 

			Cada archivo de módulo contiene definiciones de variables, funciones, clases, y puede incluso ejecutar código si se llama directamente.


	    Reutilización de Código: 

	    	Los módulos permiten la reutilización de código.

	    	Puedes definir funciones y clases en un módulo y luego importarlos en otros programas o scripts para utilizarlos.


	    Organización del Código: 

	    	Los módulos ayudan a organizar el código en partes lógicas y separadas. 

	    	Esto facilita la gestión de proyectos y la colaboración en equipos.


	Creación de un Módulo:

		Crear un módulo en Python es tan simple como crear un archivo .py y escribir código en él. 

		Por ejemplo, si tienes un archivo llamado mi_modulo.py con el siguiente contenido:


		```python

			# mi_modulo.py

			def saludar(nombre):
			    return f"Hola, {nombre}!"

			PI = 3.14159265359

		```	

		Este archivo mi_modulo.py se puede considerar un módulo:

			Contiene una función llamada saludar() y una variable llamada PI.


		Importación: 

			Para utilizar un módulo en otro script, puedes importarlo utilizando la declaración import.

			```python

				import mi_modulo

				print(mi_modulo.saludar("Juan"))
				print(mi_modulo.PI)

			```

			Importamos el módulo mi_modulo y luego hemos utilizado sus funciones y variables.


		Alias de Módulos:

			Puedes usar un alias para un módulo si deseas cambiar el nombre por uno más corto o más legible. Por ejemplo:

			```python

				import mi_modulo as mm

				print(mm.saludar("Maria"))
				print(mm.PI)

			```


		Importación Selectiva:

			Importar selectivamente funciones y variables específicas de un módulo en lugar de importar todo el módulo.

			```python

				from mi_modulo import saludar

				print(saludar("Ana"))

			```

			Solo hemos importado la función saludar desde mi_modulo, por lo que no es necesario usar el nombre del módulo al llamarla.


		Ubicación de los Módulos:

			Los módulos de Python pueden estar en diferentes ubicaciones, incluyendo el mismo directorio que tu script, en una ubicación especificada en la variable de entorno PYTHONPATH, o en las bibliotecas estándar de Python. 

			Cuando importas un módulo, Python busca en estas ubicaciones para encontrarlo.


	Built in: 

		los módulos "built-in" (incorporados) se refieren a un conjunto de módulos que son parte integral del lenguaje y se cargan automáticamente cuando se inicia una sesión de Python. 

		Estos módulos proporcionan funcionalidades esenciales que son ampliamente utilizadas en la programación cotidiana.

		Son parte de la biblioteca estandar de Python. 


		sys: 

			Este módulo proporciona acceso a variables y funciones relacionadas con la configuración y el funcionamiento del intérprete de Python. 

			Por ejemplo, puedes usar sys.argv para acceder a los argumentos de línea de comandos pasados al script Python.


	    os: 

	    	El módulo os permite interactuar con el sistema operativo subyacente. 

	    	Puedes usarlo para trabajar con archivos y directorios, realizar operaciones en el sistema de archivos y obtener información sobre el entorno del sistema.


	    math: 

	    	Este módulo proporciona funciones matemáticas avanzadas. 

	    	Puedes usarlo para realizar operaciones matemáticas más allá de las capacidades básicas de Python, como funciones trigonométricas, exponenciación y logaritmos.


	    random: 

	    	El módulo random se utiliza para generar números pseudoaleatorios. 

	    	Es útil para crear programas que requieren aleatoriedad, como juegos y simulaciones.


	    datetime: 

	    	El módulo datetime permite trabajar con fechas y horas. 

	    	Puedes crear, manipular y formatear fechas y horas utilizando las clases y funciones proporcionadas por este módulo.


	    string: 

	    	El módulo string contiene varias constantes y funciones relacionadas con cadenas de caracteres. 

	    	Por ejemplo, puedes acceder a string.ascii_letters para obtener todas las letras del alfabeto.


	    json: 

	    	Este módulo se utiliza para codificar y decodificar datos en formato JSON. 

	    	JSON es un formato de intercambio de datos común en aplicaciones web y servicios web.


	    re: 

	    	El módulo re proporciona funciones y clases para trabajar con expresiones regulares.

	    	Las expresiones regulares son patrones utilizados para buscar y manipular cadenas de texto.


	    collections: 

	    	El módulo collections ofrece tipos de datos adicionales más avanzados que los tipos de datos básicos de Python. 

	    	Incluye tipos como namedtuple, Counter, defaultdict y deque.


	    itertools: 

	    	El módulo itertools proporciona funciones para trabajar con iteradores y generadores de manera eficiente. 

	    	Puedes usarlo para realizar operaciones avanzadas en secuencias y conjuntos de datos.


	    functools: 

	    	El módulo functools contiene funciones de orden superior (higher-order functions) y herramientas para trabajar con funciones. 

	    	Incluye funciones como partial, que permite crear nuevas funciones a partir de funciones existentes.


	    pickle: 

	    	Este módulo se utiliza para serializar y deserializar objetos de Python. 

	    	Puedes usarlo para guardar objetos en archivos y luego cargarlos nuevamente en memoria.


	Customs: 

		Los módulos personalizados en Python son módulos que creas tú mismo o que provienen de terceros (como bibliotecas de código abierto) para resolver problemas específicos o para organizar tu propio código de manera más modular y legible. 

		A diferencia de los módulos "built-in" que son parte integral de Python, los módulos personalizados son aquellos que desarrollas o que obtienes de fuentes externas para abordar necesidades específicas de tu proyecto.


		Estructura de Paquetes:

			A medida que tu proyecto crece, es posible que desees organizar tus módulos personalizados en un paquete.

			Un paquete es una carpeta que contiene varios módulos y un archivo especial llamado __init__.py. 

			Esto permite una estructura más ordenada y jerárquica para tu código.

			```
				mi_proyecto/
				    __init__.py
				    modulo1.py
				    modulo2.py
				    subpaquete/
				        __init__.py
				        modulo3.py

			```

			```python

				from mi_proyecto import modulo1
				from mi_proyecto.subpaquete import modulo3

			```


	Bibliotecas Externas (pip):

		Además de crear tus propios módulos personalizados, también puedes utilizar módulos y bibliotecas externas desarrolladas por la comunidad de Python para ampliar las capacidades de tu programa. 

		Estas bibliotecas se instalan generalmente a través de administradores de paquetes como pip.



|| OPP
	
	Es un paradigma de programación que se basa en la creación y manipulación de objetos. 

	En la POO, los objetos son instancias de clases, y las clases son plantillas que definen las características y el comportamiento de esos objetos.


    Características: 

    	Clases: 

    		Una clase es una plantilla o un plano para crear objetos. 

    		Define las propiedades (atributos) y el comportamiento (métodos) que tendrán los objetos creados a partir de ella.


        Objetos: 

        	Un objeto es una instancia concreta de una clase. 

        	Los objetos tienen atributos que almacenan datos y métodos que definen su comportamiento.


        Atributos: 

        	Los atributos son variables que almacenan datos en un objeto.

        	Pueden ser variables de instancia (cada objeto tiene su propia copia) o variables de clase (compartidas entre todos los objetos de la clase).


        Métodos: 

        	Los métodos son funciones que definen el comportamiento de un objeto. 

        	Pueden ser invocados para realizar operaciones en el objeto o para interactuar con otros objetos.


        Encapsulación: 

        	La encapsulación es un concepto que implica ocultar los detalles internos de un objeto y proporcionar una interfaz clara para interactuar con él. 

        	En Python, se utiliza para definir atributos como públicos, protegidos o privados.


        Herencia: 

        	La herencia permite crear una nueva clase basada en una clase existente. 

        	La nueva clase hereda los atributos y métodos de la clase base y puede agregar o modificar su comportamiento.


        Polimorfismo: 

        	El polimorfismo permite que objetos de diferentes clases respondan de manera similar a ciertas operaciones. 

        	Esto se logra mediante la implementación de métodos con el mismo nombre en diferentes clases.


	Classes: 

        Para definir una clase en Python, utiliza la palabra clave class, seguida del nombre de la clase y un bloque de código que contiene los atributos y métodos de la clase.

        ```python

            class Persona:
                def __init__(self, nombre, edad):
                    self.nombre = nombre
                    self.edad = edad

                def saludar(self):
                    print(f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años.")

        ```

        Hemos definido una clase llamada Persona con un constructor (__init__) que inicializa los atributos nombre y edad, y un método saludar que imprime un saludo.


        Creación de Objetos:

            Para crear un objeto a partir de una clase, simplemente llama al nombre de la clase como si fuera una función.

            ```python

                juan = Persona("Juan", 30)
                maria = Persona("Maria", 25)

                juan.saludar()
                maria.saludar()

            ```

            Hemos creado dos objetos (juan y maria) de la clase Persona y luego llamado al método saludar en cada uno de ellos.


	Inherence: 

        La herencia se logra al crear una nueva clase que hereda los atributos y métodos de una clase existente. Por ejemplo:

        ```python

            class Estudiante(Persona):
                def __init__(self, nombre, edad, curso):
                    super().__init__(nombre, edad)
                    self.curso = curso

                def estudiar(self):
                    print(f"{self.nombre} está estudiando en el curso {self.curso}.")

        ```

        La clase Estudiante hereda de la clase Persona y agrega un nuevo atributo curso y un nuevo método estudiar.


        Polimorfismo:

            Se puede lograr mediante la implementación de métodos con el mismo nombre en diferentes clases. 

            Por ejemplo, tanto la clase Persona como la clase Estudiante pueden tener un método saludar, pero cada uno puede hacerlo de manera diferente.



    Casos de uso:

        La Programación Orientada a Objetos (POO) se utiliza en una amplia variedad de casos en Python y en la programación en general. 


        Modelado de Objetos del Mundo Real: 

            La POO se utiliza para modelar objetos del mundo real como clases en Python. 

            Por ejemplo, puedes crear clases como Persona, Coche, Libro, etc., para representar entidades del mundo real y luego crear objetos de estas clases para interactuar con ellos en tu programa.


        Abstracción de Datos: 

            La POO permite abstraer los detalles internos de un objeto y exponer una interfaz simple y clara para su uso.

            Esto facilita la comprensión y el uso de objetos complejos.


        Herencia: 

            La herencia se utiliza para representar relaciones entre clases. 

            Por ejemplo, una clase Vehiculo puede ser una clase base para clases más específicas como Coche y Motocicleta, heredando propiedades y métodos comunes.


        Polimorfismo: 

            El polimorfismo permite que objetos de diferentes clases respondan de manera similar a ciertas operaciones. 

            Por ejemplo, si tienes una función que acepta un objeto Animal, puedes pasar un objeto Perro o Gato y ambas clases pueden tener un método hacer_sonido() que se comporta de manera diferente.


        Encapsulación: 

            La encapsulación se utiliza para ocultar los detalles internos de un objeto y proteger sus datos.

            Esto evita el acceso no autorizado y garantiza que los cambios internos no afecten el código externo.


        Reutilización de Código: 

            La POO permite crear bibliotecas de clases que pueden ser reutilizadas en múltiples proyectos. 

            Esto ahorra tiempo y esfuerzo al no tener que volver a escribir código similar.


        Organización del Código: 

            La POO proporciona una estructura organizativa para el código. 

            Las clases y objetos ayudan a dividir un programa en componentes más manejables y cohesivos.


        Programación de Interfaz Gráfica (GUI): 

            En aplicaciones que utilizan interfaces gráficas de usuario, como ventanas y botones, la POO se utiliza para representar y controlar los elementos de la interfaz.


        Simulaciones y Juegos: 

            En aplicaciones de simulación y juegos, la POO se utiliza para representar personajes, objetos, escenarios, etc., con sus propias propiedades y comportamientos.


        Bases de Datos y ORM: 

            En el desarrollo de aplicaciones web y sistemas de gestión de bases de datos, la POO se usa en la implementación de modelos de datos y en el mapeo objeto-relacional (ORM) para interactuar con bases de datos.


	Methods: 

        Son funciones que están asociadas a objetos. 

        Los métodos son una parte fundamental de la Programación Orientada a Objetos (POO) y se utilizan para representar el comportamiento de los objetos de una clase


        Métodos de Instancia: 

            Los métodos de instancia son funciones que están asociadas a objetos individuales de una clase. 

            Pueden acceder a los atributos del objeto y realizar operaciones específicas para ese objeto en particular. 

            Se definen dentro de la clase y toman al menos un parámetro, generalmente llamado 'self', que se refiere al objeto en sí mismo.

            ```python

                class MiClase:
                    def mi_metodo(self, parametro):
                        # Hacer algo con el objeto y el parámetro
                        pass

                #Llamar a un método en un objeto particular de la clase
                objeto = MiClase()
                objeto.mi_metodo(parametro)

            ```


        Métodos Estáticos: 

            Los métodos estáticos son funciones que están asociadas a la clase en lugar de los objetos individuales. 

            No requieren el parámetro self y se definen usando el decorador @staticmethod.

            Estos métodos se utilizan cuando el comportamiento no depende de los atributos del objeto y es independiente de las instancias.

            ```python

                class MiClase:
                    @staticmethod
                    def mi_metodo_estatico(parametro):
                        # Hacer algo sin necesidad de acceder a atributos de instancia
                        pass

                #Podemos llamar a un método estático en la clase misma, sin crear un objeto
                MiClase.mi_metodo_estatico(parametro)

            ```


        Métodos de Clase: 

            Los métodos de clase son similares a los métodos estáticos, pero pueden acceder y modificar los atributos de la clase. 

            Se definen utilizando el decorador @classmethod y toman un parámetro especial llamado cls, que hace referencia a la clase en sí misma.

            ```python

                class MiClase:
                    atributo_clase = 0

                    @classmethod
                    def mi_metodo_de_clase(cls):
                        cls.atributo_clase += 1

                #Llamar a un método de clase en la clase misma
                MiClase.mi_metodo_de_clase()

            ```

            Esto modificará el atributo de clase atributo_clase.


        Métodos Mágicos (Dunder Methods):

            Son métodos especiales que tienen nombres que comienzan y terminan con doble guión bajo (por ejemplo, __init__, __str__, __add__). 

            Estos métodos permiten definir el comportamiento especial de los objetos en ciertas situaciones, como la inicialización de objetos, la representación de objetos como cadenas y la sobrecarga de operadores.

            ```python

                class MiClase:
                    def __init__(self, valor):
                        self.valor = valor

                    def __str__(self):
                        return f"Objeto de MiClase con valor {self.valor}"

            ``` 

            Los métodos mágicos se llaman automáticamente en respuesta a ciertos eventos, como la creación de un objeto o la conversión a cadena.


	Dunder: 

        "Dunder" es una abreviatura de "Double Underscore" (doble guion bajo) y se refiere a los métodos mágicos o especiales que tienen nombres que comienzan y terminan con doble guion bajo, como __init__, __str__, __add__, entre otros. Estos métodos mágicos son llamados automáticamente por Python en respuesta a ciertos eventos o acciones específicas.

        Permiten definir el comportamiento especial de los objetos de una clase en diferentes situaciones.


        __init__: 

            Este método se llama automáticamente cuando se crea una nueva instancia de la clase. 

            Se utiliza para inicializar los atributos del objeto.

            ```python

                class Persona:
                    def __init__(self, nombre, edad):
                        self.nombre = nombre
                        self.edad = edad

                #Llamada a la clase y uso en objeto
                persona = Persona("Alice", 30)

            ```


        __str__: 

            Este método se llama automáticamente cuando se intenta convertir un objeto en una cadena usando la función str() o cuando se imprime el objeto. 

            Se utiliza para proporcionar una representación legible del objeto.

            ```python

                class Libro:
                    def __init__(self, titulo, autor):
                        self.titulo = titulo
                        self.autor = autor

                    def __str__(self):
                        return f"{self.titulo} por {self.autor}"

                #Conversión y uso del objeto
                libro = Libro("La Sombra del Viento", "Carlos Ruiz Zafón")
                print(str(libro))  # Salida: La Sombra del Viento por Carlos Ruiz Zafón

            ```


        __add__: 

            Este método se llama automáticamente cuando se utiliza el operador + entre dos objetos de la clase. Permite definir cómo se deben sumar los objetos.

            ```python
           
                class Punto:
                    def __init__(self, x, y):
                        self.x = x
                        self.y = y

                    def __add__(self,   otro_punto):
                        return Punto(self.x + otro_punto.x, self.y + otro_punto.y)

                #Llamada
                punto1 = Punto(1, 2)
                punto2 = Punto(3, 4)
                resultado = punto1 + punto2  # Usando la sobrecarga de operador +


            ``` 

        Los métodos dunder permiten personalizar el comportamiento de tus clases y objetos en situaciones específicas. 

        Al implementar estos métodos en tu clase, puedes controlar cómo se comportan tus objetos cuando se utilizan en diversas operaciones y contextos.


        Lista de dunders: 

            __init__(self, ...):

                Inicializa un objeto cuando se crea una nueva instancia de la clase.


            __del__(self): 

                Se llama cuando un objeto se destruye o se elimina. No se recomienda su uso frecuente.


            __str__(self): 

                Se llama cuando se convierte un objeto en una cadena usando la función str() o cuando se imprime el objeto.


            __repr__(self): 

                Se llama cuando se utiliza la función repr() para obtener una representación textual del objeto. 

                Debe ser una representación válida de Python que permita recrear el objeto.


            __len__(self): 

                Se llama cuando se utiliza la función len() para obtener la longitud de un objeto. 

                Debe devolver un valor entero no negativo.


            __getitem__(self, key): 

                Se llama cuando se accede a un elemento de un objeto mediante indexación, por ejemplo, objeto[clave].


            __setitem__(self, key, valor): 

                Se llama cuando se asigna un valor a un elemento de un objeto mediante indexación, por ejemplo, objeto[clave] = valor.


            __delitem__(self, key): 

                Se llama cuando se elimina un 

                elemento de un objeto mediante la instrucción del objeto[clave].


            __iter__(self): 

                Se llama cuando se inicia una iteración sobre un objeto. 

                Debe devolver un iterador, generalmente a sí mismo.


            __next__(self): 

                Se llama para obtener el siguiente elemento en una iteración. 

                Debe elevar la excepción StopIteration cuando no haya más elementos.


            __contains__(self, elemento):

                Se llama cuando se utiliza el operador in para verificar si un elemento está presente en el objeto.


            __eq__(self, otro): 

                Se llama para comparar si dos objetos son iguales usando el operador ==.


            __ne__(self, otro): 

                Se llama para comparar si dos objetos no son iguales usando el operador !=.


            __lt__(self, otro): 

                Se llama para comparar si un objeto es menor que otro usando el operador <.

            __le__(self, otro): 
                
                Se llama para comparar si un objeto es menor o igual que otro usando el operador <=.


            __gt__(self, otro): 

                Se llama para comparar si un objeto es mayor que otro usando el operador >.


            __ge__(self, otro): 

                Se llama para comparar si un objeto es mayor o igual que otro usando el operador >=.


            __add__(self, otro): Se llama cuando se utiliza el operador + para sumar dos objetos.


            __sub__(self, otro): 

                Se llama cuando se utiliza el operador - para restar dos objetos.


            __mul__(self, otro): 

                Se llama cuando se utiliza el operador * para multiplicar dos objetos.


            __truediv__(self, otro): 

                Se llama cuando se utiliza el operador / para dividir dos objetos.


            __floordiv__(self, otro): 

                Se llama cuando se utiliza el operador // para realizar una división entera entre dos objetos.


            __mod__(self, otro): 

                Se llama cuando se utiliza el operador % para obtener el residuo de la división entre dos objetos.


            __pow__(self, otro, modulo=None): 

                Se llama cuando se utiliza el operador ** para elevar un objeto a una potencia.



|| PACKAGE MANAGERS

    
    Son herramientas que facilitan la gestión de paquetes de software, bibliotecas y dependencias en proyectos de Python. 

    Estos gestores permiten la instalación, actualización y eliminación de paquetes de manera sencilla y automatizada. 

    Los dos gestores de paquetes más comunes en Python son:

    1. pip: 

        Pip es el gestor de paquetes predeterminado de Python. 

        Se utiliza para instalar, actualizar y eliminar paquetes de Python desde el Python Package Index (PyPI) y otros repositorios. 

        Algunos comandos básicos de pip incluyen:

        pip install "paquete": 

            Instala un paquete.


        pip install paquete==versión:

            Instala una versión específica de un paquete.


        pip install -r requirements.txt:

            Instala paquetes enumerados en un archivo requirements.txt.


        pip uninstall paquete: 

            Desinstala un paquete.


        pip list: 

            Muestra la lista de paquetes instalados.


        ```
            pip install requests

        ```


    2. conda:   

        Conda es un gestor de paquetes y un sistema de administración de entornos desarrollado principalmente para la ciencia de datos y la informática científica. 

        Es especialmente útil para crear entornos virtuales de Python y gestionar las dependencias. 


        Algunos comandos básicos de conda incluyen:

        conda create --name mi_entorno python=3.8: 

            Crea un nuevo entorno virtual.
        

        conda activate mi_entorno: 

            Activa un entorno virtual.


        conda install paquete: 

            Instala un paquete en el entorno activo.


        conda update paquete: 

            Actualiza un paquete en el entorno activo.


        conda list: 

            Muestra la lista de paquetes instalados en el entorno activo.


        conda env export > environment.yml: 

            Exporta el entorno a un archivo YAML.


        Ejemplo de creación de un entorno virtual con conda:

        ```
            conda create --name myenv python=3.8

        ```


    Ambos gestores de paquetes son ampliamente utilizados en el ecosistema de Python. 

    La elección entre pip y conda depende en gran medida del tipo de proyecto que estés desarrollando y de tus necesidades específicas. 

    Pip es más común para proyectos generales de Python, mientras que conda es preferido en el ámbito de la ciencia de datos y la informática científica debido a su capacidad para gestionar entornos virtuales de manera eficaz.

    Es importante destacar que, además de estos dos gestores de paquetes, existen otros como poetry y pipenv que ofrecen características adicionales para la gestión de proyectos y dependencias en Python. 

    La elección del gestor de paquetes y las herramientas adicionales dependerá de tus necesidades y preferencias.


    PyPI: 

        PyPI es el acrónimo de "Python Package Index" (Índice de Paquetes de Python) y es un repositorio en línea de paquetes de software de código abierto para el lenguaje de programación Python. 

        PyPI es el lugar donde los desarrolladores de Python pueden cargar y compartir sus bibliotecas y paquetes Python para que otros los utilicen en sus proyectos. 


        Aquí hay algunas características y aspectos importantes de PyPI:

        Almacenamiento de Paquetes: 

            PyPI almacena miles de paquetes de software Python, desde bibliotecas populares hasta paquetes más especializados. 

            Los paquetes en PyPI son versionados, lo que permite a los desarrolladores especificar la versión exacta que desean utilizar en sus proyectos.


        Instalación con pip: 

            PyPI es el repositorio predeterminado para pip, el gestor de paquetes de Python.

            Esto significa que los desarrolladores pueden utilizar pip para buscar, instalar y actualizar paquetes directamente desde PyPI. 
            Por ejemplo, pip install nombre_paquete descargará e instalará automáticamente el paquete desde PyPI.


        Repositorio Abierto: 

            PyPI es un repositorio abierto, lo que significa que cualquier persona puede registrarse y cargar sus propios paquetes Python. 

            Esto ha llevado a una gran comunidad de desarrolladores que contribuyen con paquetes y bibliotecas útiles para la comunidad de Python.


        Documentación y Metadatos: 

            Los paquetes en PyPI suelen estar acompañados de documentación detallada, lo que facilita su uso por parte de otros desarrolladores.

            También contienen metadatos como el nombre del autor, la licencia del software, la versión y otros detalles útiles.


        Herramientas para Desarrolladores: 

            PyPI ofrece API y herramientas para desarrolladores que desean automatizar tareas relacionadas con la gestión de paquetes. 

            Esto permite la creación de herramientas de construcción y publicación personalizadas.


        Seguridad: 

            PyPI se esfuerza por mantener un alto nivel de seguridad. Realiza escaneos de seguridad de paquetes cargados y emite advertencias si se encuentran vulnerabilidades conocidas. 

            Los usuarios son alentados a reportar problemas de seguridad.


        Colaboración: 

            PyPI es un proyecto de código abierto en sí mismo y se encuentra en constante desarrollo. 

            La comunidad de Python colabora para mejorar la infraestructura y la experiencia del usuario en PyPI.


        En resumen, PyPI es una parte fundamental del ecosistema de Python, ya que proporciona un lugar centralizado para descubrir, distribuir y compartir paquetes de software Python. 

        Los desarrolladores de Python pueden utilizar PyPI para acceder a una amplia variedad de recursos y acelerar el desarrollo de sus proyectos al aprovechar las bibliotecas y paquetes disponibles.


        Acceso a PyPI: 

            1. Línea de comandos:

                Instalar paquetes:

                    Utiliza el comando pip install seguido del nombre del paquete que deseas instalar. 

                    Por ejemplo, para instalar el paquete requests, puedes ejecutar pip install requests.


                Actualizar paquetes:

                    Puedes actualizar los paquetes instalados utilizando pip con el comando pip install --upgrade nombre_paquete.


                Buscar paquetes: 

                    Puedes buscar paquetes disponibles en PyPI utilizando pip search. 

                    Por ejemplo, pip search nombre_paquete.


            2. Navegar el sitio web de PyPI:

                PyPI tiene un sitio web en https://pypi.org/ donde puedes buscar y explorar paquetes. 

                Puedes utilizar la interfaz de búsqueda en línea para encontrar paquetes específicos y obtener información detallada sobre cada paquete, incluyendo su documentación y metadatos.


        Utilizar herramientas de gestión de entornos virtuales:

            Si estás trabajando en un proyecto que requiere entornos virtuales (como conda o virtualenv), puedes utilizar las herramientas de gestión de entornos para instalar paquetes desde PyPI en un entorno aislado. 

            Esto es útil para evitar conflictos de dependencias entre proyectos.



|| LIST COMPREHENSIONS

    Es una forma concisa y elegante de crear listas. 

    Permiten crear una nueva lista aplicando una expresión a cada elemento de una secuencia (como una lista, tupla, rango, etc.) y, opcionalmente, aplicar una condición para filtrar los elementos.

    ```python

        nueva_lista = [expresion for elemento in secuencia]

    ```

    expresion: 

        Es una expresión que se aplica a cada elemento de la secuencia para crear los elementos de la nueva lista.


    elemento: 

        Es una variable temporal que toma el valor de cada elemento de la secuencia en cada iteración.


    secuencia: 

        Es la secuencia de elementos sobre la cual se realiza la iteración.


    Además, puedes agregar una cláusula if para filtrar elementos de la secuencia según una condición:

    ```python

        nueva_lista = [expresion for elemento in secuencia if condicion]

    ```

    condicion: 

        Es una expresión booleana que determina si el elemento debe incluirse en la nueva lista o no.


    Ejemplos: 

        1. Crear una lista de los cuadrados de los números del 0 al 9:

            ```python

                cuadrados = [x**2 for x in range(10)]
                # Resultado: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

            ```


        2. Filtrar números pares de una lista:

            ```python

                numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                pares = [x for x in numeros if x % 2 == 0]
                # Resultado: [2, 4, 6, 8]

            ``` 

        3. Crear una lista de las letras iniciales de una lista de palabras:

            ```python

                palabras = ['manzana', 'banana', 'cereza']
                iniciales = [palabra[0] for palabra in palabras]
                # Resultado: ['m', 'b', 'c']

            ```


    Son una forma poderosa y legible de transformar y filtrar datos en Python. 

    Son especialmente útiles cuando se desea crear una nueva lista basada en una secuencia existente sin necesidad de bucles for explícitos.



|| GENERATOR EXPRESSIONS
    
    Son similares a las "List Comprehensions" (comprensiones de lista), pero en lugar de crear una lista completa en la memoria, generan elementos uno a uno de manera eficiente y bajo demanda. 

    Esto las hace ideales para trabajar con secuencias largas de datos sin ocupar mucha memoria.

    Sintaxis: 

        Similar a la de una comprensión de lista, pero se utiliza paréntesis en lugar de corchetes:

        ```python

            generador = (expresion for elemento in secuencia)
       
        ```

        expresion: 

            Es una expresión que se aplica a cada elemento de la secuencia para generar los valores uno a uno.


        elemento: 

            Es una variable temporal que toma el valor de cada elemento de la secuencia en cada iteración.


        secuencia: 

            Es la secuencia de elementos sobre la cual se realiza la iteración.


   Ejemplo: 
    

        ```python

            numeros = [1, 2, 3, 4, 5]

            # Crear una expresión generadora para generar los cuadrados de los números
            generador_cuadrados = (x**2 for x in numeros)

            # Puedes obtener los valores uno a uno utilizando un bucle for o la función next()
            for cuadrado in generador_cuadrados:
                print(cuadrado)

            # Resultado:
            # 1
            # 4
            # 9
            # 16
            # 25

        ```

        Eficiencia de memoria: 

            Dado que los elementos se generan bajo demanda, no es necesario almacenar toda la secuencia en memoria, lo que es beneficioso para secuencias largas.


        Velocidad: 

            Las expresiones generadoras pueden ser más rápidas que las listas si solo necesitas iterar una vez sobre los elementos, ya que no se realiza una copia completa de los datos.


        Legibilidad: 

            Mantienen la misma sintaxis concisa y legible que las comprensiones de lista, lo que facilita la escritura de código limpio y claro.

 

|| PARADIGMS 
    
    Se refiere a un enfoque o estilo particular de programación que se utiliza para resolver problemas.

    Python es un lenguaje de programación multiparadigma, lo que significa que admite varios enfoques diferentes para la programación.

    La elección del paradigma depende del tipo de problema que estés resolviendo y de tu estilo de programación preferido. 

    Python proporciona flexibilidad para utilizar múltiples enfoques y paradigmas en un solo programa si es necesario.


    Programación Imperativa:

        Descripción: 

            En este paradigma, el programa se estructura en torno a secuencias de instrucciones que modifican el estado de las variables y los datos. 

            Se enfoca en "cómo" se deben realizar las acciones.


        Características: 

            Variables, asignaciones, bucles, estructuras condicionales.


        ```python

            total = 0
            for numero in range(1, 6):
                total += numero
            print(total)

        ```


    Programación Orientada a Objetos (POO):

        Descripción: 

            La POO se basa en la idea de organizar el código en objetos, que son instancias de clases. 

            Cada objeto tiene atributos y métodos que encapsulan su estado y comportamiento.


        Características: 

            Clases, objetos, encapsulación, herencia, polimorfismo.


        ```python

            class Animal:
                def __init__(self, nombre):
                    self.nombre = nombre

                def hablar(self):
                    pass

            class Perro(Animal):
                def hablar(self):
                    return "Woof!"

            class Gato(Animal):
                def hablar(self):
                    return "Meow!"

            fido = Perro("Fido")
            whiskers = Gato("Whiskers")

            print(fido.hablar())  # Salida: "Woof!"
            print(whiskers.hablar())  # Salida: "Meow!"

        ```


    Programación Funcional:

        Descripción: 

            Se centra en el uso de funciones puras, donde una función siempre produce el mismo resultado para los mismos argumentos y no tiene efectos secundarios. 

            Se enfoca en "qué" debe hacerse.


        Características: 

            Funciones de orden superior, inmutabilidad, expresiones lambda, map, filter, reduce.


        ```python

            numeros = [1, 2, 3, 4, 5]

            # Usando la función map para aplicar una función a cada elemento
            cuadrados = list(map(lambda x: x**2, numeros))
            # Resultado: [1, 4, 9, 16, 25]

        ```


    Programación Declarativa:

        Descripción: 

            Este paradigma se centra en describir "qué" se debe lograr en lugar de "cómo" hacerlo. 

            Se utilizan declaraciones y expresiones para definir el resultado deseado, y el lenguaje de programación se encarga de la implementación.
        

        Características: 

            SQL (para consultas de bases de datos), HTML (para diseño web).


        Ejemplo (usando SQL):

            ```python

                import sqlite3

                # Crear una conexión a una base de datos SQLite en memoria
                conn = sqlite3.connect(':memory:')
                cursor = conn.cursor()

                # Crear una tabla y agregar datos
                cursor.execute('''
                    CREATE TABLE usuarios (id INTEGER PRIMARY KEY, nombre TEXT, edad INTEGER)
                ''')

                cursor.execute('''
                    INSERT INTO usuarios (nombre, edad) VALUES (?, ?)
                ''', ('Alice', 25))

                # Realizar una consulta declarativa
                cursor.execute('SELECT nombre FROM usuarios WHERE edad > ?', (18,))
                resultados = cursor.fetchall()

                print(resultados)  # Salida: [('Alice',)]

            ```


    Programación Modular:

        Descripción: 

            Este paradigma se centra en dividir un programa grande en módulos más pequeños y manejables. 

            Cada módulo contiene funciones, clases y variables que realizan tareas específicas y pueden reutilizarse en otros programas.


        Características: 

            Módulos, importación y reutilización de código.


        ```python

            # Módulo principal
            import mi_modulo

            resultado = mi_modulo.suma(5, 3)
            print(resultado)

        ```



|| Async

    La programación asíncrona en Python se refiere a la capacidad de realizar tareas de manera concurrente y eficiente, sin bloquear la ejecución del programa principal. 

    Permite que partes de un programa se ejecuten en segundo plano mientras otras partes continúan su ejecución.

    Esto es especialmente útil para tareas de entrada/salida (E/S) intensivas, como solicitudes de red, acceso a bases de datos y operaciones de archivos, donde la espera de una respuesta puede ser costosa en términos de tiempo.

    La programación asíncrona es especialmente útil en aplicaciones web y en situaciones en las que se necesitan altos niveles de concurrencia, como servidores y aplicaciones que requieren interacciones en tiempo real. 

    Es valiosa en situaciones donde la eficiencia y la capacidad de respuesta son críticas, especialmente en aplicaciones que deben manejar múltiples tareas concurrentes.

    Python proporciona la biblioteca asyncio para admitir la programación asíncrona de manera nativa y eficiente.


    Conceptos: 

        async def: 

            Permite definir funciones asincrónicas. 

            Una función asincrónica es una función que puede pausar su ejecución y liberar el control de manera que otras tareas puedan ejecutarse mientras espera una operación larga o bloqueante.

            ```python

                import asyncio

                async def hacer_algo():
                    await asyncio.sleep(1)
                    print("Hecho")

                asyncio.run(hacer_algo())

            ```

            hacer_algo() es una función asincrónica que pausa su ejecución durante 1 segundo utilizando await asyncio.sleep(1) y luego imprime "Hecho". 

            Durante esa pausa, el control se devuelve al bucle de eventos de asyncio para realizar otras tareas.


        await: 

            Se usa dentro de una función asincrónica para esperar una operación asincrónica, como una llamada a otra función asincrónica o una tarea que puede tomar un tiempo desconocido. 

            La ejecución de la función se detendrá en el punto donde se encuentra el await hasta que la operación se complete

            ```python

                async def obtener_datos():
                    # Simulando una operación larga
                    await asyncio.sleep(2)
                    return "Datos obtenidos"

                async def principal():
                    resultado = await obtener_datos()
                    print(resultado)

                asyncio.run(principal())

            ```

            await asyncio.sleep(2) pausa la ejecución durante 2 segundos, y luego se recoge el resultado "Datos obtenidos". 

            La función principal() utiliza await obtener_datos() para esperar a que obtener_datos() se complete antes de continuar.


    Corrutinas (Coroutines):

        Las corrutinas son funciones especiales definidas con la palabra clave async def. 

        Pueden suspender su ejecución en puntos específicos utilizando await, lo que permite que otras tareas se ejecuten mientras esperan una operación asíncrona.

        ```python

            async def mi_corrutina():
                print("Inicio de la corrutina")
                await asyncio.sleep(1)
                print("Fin de la corrutina")

        ```


    Loop de Eventos (Event Loop):

        El bucle de eventos (a menudo denominado "event loop") es una estructura que administra y coordina la ejecución de tareas asíncronas en Python. 

        En Python, el módulo asyncio proporciona un bucle de eventos para gestionar tareas asíncronas.

        Ejemplo de uso de asyncio:

        ```python

            import asyncio

            async def main():
                await asyncio.gather(mi_corrutina(), otra_corrutina())

            asyncio.run(main())

        ```


    Awaitable Objects:

        Un "awaitable" es un objeto que se puede esperar (await) en una corrutina. 

        Esto incluye corrutinas, objetos de tipo asyncio.Future, generadores asíncronos y otros objetos definidos para ser esperados.
        
        Ejemplo de un objeto asyncio.Future:

        ```python

            import asyncio

            async def obtener_resultado():
                await asyncio.sleep(1)
                return "Resultado"

            async def main():
                resultado = await obtener_resultado()
                print(resultado)

            asyncio.run(main())

        ```


    Multiprocesamiento vs. Multihilos:

        La programación asíncrona se diferencia de la programación multiproceso y multihilo en que no implica la creación de múltiples subprocesos o procesos completos. 

        En cambio, utiliza un solo hilo de ejecución (thread) para gestionar tareas en un bucle de eventos. 

        Esto puede ser más eficiente en términos de recursos, especialmente para E/S intensivas.


    Manejo de Excepciones:

        La programación asíncrona en Python también incluye la capacidad de manejar excepciones de manera adecuada en tareas asíncronas. 

        Se pueden utilizar bloques try y except en las corrutinas para capturar excepciones y manejar errores.


    Eventos y Callbacks:

        En algunos casos, se utilizan eventos y callbacks para manejar tareas asíncronas. 

        Los eventos se desencadenan cuando ocurre algo, y los callbacks son funciones que se ejecutan en respuesta a un evento específico.


    Tareas Concurrentes:

        La programación asíncrona permite ejecutar múltiples tareas de manera concurrente sin bloquear el hilo principal. 

        Esto mejora la capacidad de respuesta de las aplicaciones y permite una mejor utilización de los recursos del sistema.


    Casos de uso:

        Aplicaciones Web y API:
            
            En aplicaciones web y API, las solicitudes de clientes pueden ser manejadas de manera asíncrona para evitar bloqueos en el servidor. 

            Esto es especialmente útil en aplicaciones con un gran número de solicitudes concurrentes.


        Acceso a Bases de Datos:

            Cuando se accede a bases de datos, a menudo se producen demoras debido a la latencia de la red o el disco. 

            La programación asíncrona permite enviar consultas a la base de datos y continuar realizando otras tareas mientras se espera la respuesta.


        Acceso a APIs Externas:

            Al interactuar con servicios web externos, como servicios de redes sociales o servicios de terceros, la programación asíncrona permite realizar múltiples solicitudes de manera eficiente sin bloquear la aplicación mientras se espera la respuesta de cada solicitud.


        Procesamiento de Archivos Grandes:

            Cuando se procesan archivos grandes, como archivos de registro o archivos de datos masivos, la programación asíncrona permite leer y procesar datos en fragmentos, lo que reduce la necesidad de cargar todo el archivo en la memoria.


        Streaming de Datos en Tiempo Real:

            Para aplicaciones que requieren el streaming de datos en tiempo real, como transmisiones en vivo o juegos en línea, la programación asíncrona es esencial para garantizar que los datos se entreguen de manera oportuna y sin demoras significativas.


        Notificaciones y Actualizaciones en Tiempo Real:

            En aplicaciones que deben proporcionar notificaciones en tiempo real a los usuarios, como sistemas de chat o aplicaciones de seguimiento en tiempo real, la programación asíncrona facilita la entrega de mensajes y actualizaciones instantáneas.


        Procesamiento Paralelo:

            La programación asíncrona se utiliza para realizar múltiples tareas en paralelo, como el procesamiento de imágenes, el procesamiento de videos y la simulación de sistemas complejos.


        Web Scraping:

            Al recopilar datos de múltiples sitios web, la programación asíncrona permite enviar solicitudes simultáneas a diferentes páginas web y procesar las respuestas de manera eficiente.


        Programación de E/S Intensiva:

            Cualquier aplicación que realice operaciones intensivas de entrada/salida, como copiar archivos, descargar recursos web o realizar análisis de texto, puede beneficiarse de la programación asíncrona para evitar bloqueos.


        Control de Dispositivos Periféricos:

            En aplicaciones que controlan dispositivos periféricos, como sensores o actuadores, la programación asíncrona permite recibir y procesar datos de manera continua sin interrupciones.


    Biblioteca asyncio:     

        Se introdujo por primera vez en Python 3.3.

        Origen: 

            Se introdujo en Python para abordar la programación asíncrona y la concurrencia de manera nativa en el lenguaje. 

            Antes de asyncio, se utilizaban varias bibliotecas de terceros para manejar la programación asíncrona, lo que a menudo generaba problemas de compatibilidad y complejidad.


        Propósito: 

            El propósito principal de asyncio es proporcionar una infraestructura para escribir código asincrónico de manera más sencilla y eficiente. 

            Permite a los desarrolladores escribir código que pueda manejar tareas concurrentes sin bloquear el hilo principal de ejecución. 

            Esto es especialmente útil en aplicaciones que requieren alta concurrencia, como servidores web, aplicaciones de red, procesamiento paralelo y más.



        Actualidad: 

            Sigue siendo una parte esencial del ecosistema de Python y se utiliza en una amplia variedad de aplicaciones y bibliotecas. 

            Muchos servidores web, frameworks web como FastAPI y aplicaciones de procesamiento de datos aprovechan asyncio para ofrecer alto rendimiento y escalabilidad.
            
            La biblioteca ha madurado desde su introducción y ha experimentado mejoras continuas en términos de rendimiento y características en las versiones de Python posteriores.


        Características:

            asyncio se basa en el modelo de programación asíncrona y utiliza las palabras clave async y await para definir y gestionar funciones asincrónicas. Las principales características incluyen:

            Un bucle de eventos (event loop) que permite la ejecución concurrente de tareas.

            Soporte para I/O asíncrona, como operaciones de red y lectura/escritura de archivos.
            La capacidad de crear y gestionar tareas asincrónicas de manera eficiente.

            Herramientas para la sincronización y comunicación entre tareas, como semáforos y colas.


        Funciones: 

            asyncio.run(coroutine): 

                Ejecuta una corutina de nivel superior. 

                Se utiliza para iniciar la ejecución de un programa asincrónico.


            asyncio.create_task(coroutine): 

                Crea una tarea asincrónica para ejecutar una corutina de manera concurrente.


            asyncio.sleep(seconds): 

                Pausa la ejecución de una corutina durante un período especificado en segundos.


            asyncio.wait(tasks): 

                Espera a que todas las tareas especificadas se completen.


            asyncio.gather(*coroutines):

                Ejecuta varias corutinas de manera concurrente y espera a que todas se completen.


        Event Loop:

            asyncio.get_event_loop(): 

                Obtiene el bucle de eventos actual.


            loop.create_task(coroutine):

                Crea una tarea asincrónica en un bucle de eventos.


        Semáforos y Locks:

            asyncio.Semaphore(value=1):

                Un semáforo que permite un número máximo de operaciones concurrentes.


            asyncio.Lock(): 

                Un candado que se utiliza para evitar que varias tareas accedan a una sección crítica de código al mismo tiempo.


        Comunicación entre Tareas:

            asyncio.Queue(): 

                Una cola asincrónica que permite la comunicación entre tareas.


            asyncio.Event(): 

                Un evento asincrónico que se puede esperar y establecer.


        Manejo de Excepciones:

            asyncio.TimeoutError: 

                Una excepción lanzada cuando se supera un tiempo de espera.


        Funciones de I/O Asíncrono:

            asyncio.open_connection(): 

                Crea una conexión TCP asincrónica.


            asyncio.start_server(): 

                Inicia un servidor TCP asincrónico.


        Funciones de Subprocesos Asíncronos:

            asyncio.create_subprocess_exec(): 

                Crea un nuevo proceso y devuelve un objeto de proceso asincrónico.


            asyncio.Process(): 

                Un objeto que representa un proceso en ejecución.


        Otros Métodos Útiles:

            asyncio.shield(): 

                Protege una tarea asincrónica de ser cancelada por una excepción.


            asyncio.run_coroutine_threadsafe(): 

                Ejecuta una corutina de manera segura desde un subproceso diferente.


    Event Loop: 

        Se utiliza para gestionar tareas asíncronas y eventos en un programa.

        Es importante en el contexto de la programación asíncrona y la concurrencia, donde se deben realizar múltiples tareas sin bloquear el flujo principal del programa.


        Funcionamiento: 

            Registro de tareas: 

                En un Event Loop, puedes registrar tareas que deben ejecutarse de manera asíncrona. 

                Estas tareas pueden ser funciones que realicen operaciones de E/S, solicitudes a la red u otras operaciones que puedan bloquear el flujo principal del programa.


            Ejecución asíncrona: 

                El Event Loop se encarga de ejecutar estas tareas de manera asíncrona. 

                Esto significa que las tareas pueden ejecutarse en segundo plano sin bloquear la ejecución del programa principal.


            Gestión de eventos:     

                Además de tareas asíncronas, un Event Loop también puede gestionar eventos, como eventos de entrada/salida (E/S) o eventos del sistema.

                Cuando ocurre un evento, el Event Loop puede desencadenar una función de manejo de eventos asociada.


            No bloqueante: 

                La principal ventaja de un Event Loop es que permite que el programa continúe ejecutándose sin bloqueos. 

                En lugar de esperar a que una tarea se complete, el programa puede continuar con otras tareas o manejar eventos adicionales.


        Caso de uso común: 

           Es en aplicaciones web o servidores. 
           
           Cuando un servidor web recibe múltiples solicitudes de clientes, no puede bloquear el procesamiento de una solicitud mientras espera a que se complete otra. 

           En su lugar, utiliza un Event Loop para manejar múltiples solicitudes de manera asíncrona. 



