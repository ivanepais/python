# Documentación de Python

|| PYTHON
	
	Fue creado a finales de los años 80 y principios de los 90 por Guido van Rossum, un programador holandés. 

	Su objetivo principal era desarrollar un lenguaje de programación que fuera fácil de leer, escribir y comprender.

	Van Rossum quería un lenguaje que promoviera una sintaxis clara y un enfoque práctico en lugar de ser excesivamente complejo. 

	Python tomó inspiración de lenguajes como ABC, Modula-3 y otros.


	Propósito:

		El propósito principal de Python era ser un lenguaje general de propósito que pudiera ser utilizado para una amplia gama de aplicaciones, desde desarrollo web hasta scripting, análisis de datos, automatización, inteligencia artificial y más.

		Python se centró en la legibilidad y la facilidad de uso, lo que lo hace especialmente adecuado para principiantes y programadores experimentados por igual.

		Además de su legibilidad, Python también promueve la filosofía de "baterías incluidas", lo que significa que viene con una amplia biblioteca estándar que proporciona módulos y funciones para muchas tareas comunes, lo que simplifica el desarrollo.

		
	Actualidad:

		Hoy en día, Python es uno de los lenguajes de programación más populares y ampliamente utilizados en todo el mundo.

		Ha ganado una gran adopción en diversos campos debido a su versatilidad y facilidad de uso. Algunos de los usos más destacados de Python incluyen:


    Desarrollo Web: 

    	Python se utiliza en el desarrollo de aplicaciones web a través de frameworks como Django y Flask, que facilitan la creación de aplicaciones robustas y escalables.


    Ciencia de Datos y Análisis: 

    	Python es muy popular en la comunidad de ciencia de datos debido a bibliotecas como NumPy, pandas, Matplotlib y scikit-learn, que facilitan el análisis y la visualización de datos.


    Inteligencia Artificial y Aprendizaje Automático: 

    	Python es un lenguaje preferido para la implementación de algoritmos de aprendizaje automático e inteligencia artificial debido a bibliotecas como TensorFlow y PyTorch.


    Automatización y Scripting: 

    	Python es ampliamente utilizado para la automatización de tareas y la creación de scripts debido a su legibilidad y facilidad de uso.


    Aplicaciones Científicas y de Ingeniería: 

    	Python se utiliza en aplicaciones científicas y de ingeniería, como simulaciones, modelado numérico y más.


	Python continúa evolucionando con nuevas versiones y mejoras. 

	La comunidad de Python es activa y contribuye con paquetes y bibliotecas de código abierto para abordar una amplia variedad de problemas y aplicaciones. 



|| CARACTERÍSTICAS

	Es un lenguaje de programación de alto nivel, interpretado y de propósito general. 

	Fue diseñado para ser legible y fácil de entender, lo que lo hace adecuado tanto para principiantes como para programadores experimentados. 

	Python se destaca por su sintaxis clara y su enfoque en la legibilidad del código, lo que facilita la escritura y el mantenimiento de programas.


    Sintaxis clara: 

    	Python se enorgullece de tener una sintaxis simple y fácil de leer, lo que facilita la comprensión del código incluso para aquellos que son nuevos en la programación.


    Tipado dinámico: 

    	No necesitas declarar el tipo de variable antes de usarla. 

    	Python infiere automáticamente el tipo de datos basándose en el valor asignado.


    Interpretado: 

    	Python es un lenguaje interpretado, lo que significa que no es necesario compilar el código antes de ejecutarlo. 

    	El intérprete de Python traduce el código línea por línea en tiempo real.


    Multiplataforma: 

    	Puedes escribir y ejecutar código Python en varias plataformas, como Windows, macOS y Linux, sin preocuparte por cambios significativos en el código.


    Amplia biblioteca estándar: 

    	Python viene con una gran biblioteca estándar que ofrece una amplia gama de módulos y funciones que facilitan tareas comunes, desde manipulación de cadenas hasta acceso a redes y manejo de archivos.



|| FUNCIONAMIENTO

    Escritura del código: 

    	Los programadores escriben el código fuente de sus programas en archivos con extensión .py. 

    	Estos archivos contienen instrucciones escritas en el lenguaje Python.


    Interpretación: 

    	Cuando ejecutas un archivo .py, el intérprete de Python procesa el código línea por línea y ejecuta las instrucciones. 

    	No es necesario compilar el código en un archivo ejecutable separado.


    Creación de objetos: 

    	Python es un lenguaje orientado a objetos. 

    	Los datos y las funcionalidades se organizan en objetos y clases. 

    	Los objetos son instancias de clases que contienen atributos y métodos.


    Gestión de memoria: 

    	Python administra automáticamente la asignación y liberación de memoria para objetos. 

    	Utiliza un mecanismo llamado "recolección de basura" para liberar la memoria de objetos que ya no son necesarios.


    Interacción con el sistema: 

    	Python puede interactuar con el sistema operativo, acceder a archivos, redes y recursos externos a través de módulos incorporados o de terceros.


    Ejecución de scripts: 

    	Además de ejecutar programas en la consola interactiva de Python, también puedes crear scripts que se ejecutan como programas independientes desde la línea de comandos.


    Importación de módulos: 

    	Python facilita la reutilización de código al permitir la importación de módulos y bibliotecas predefinidos o creados por los usuarios.


    Depuración y pruebas: 

    	Python ofrece herramientas para depurar y probar el código, como la función print() para imprimir valores y herramientas más avanzadas para rastrear errores.


	En resumen, Python es un lenguaje de programación versátil y potente que se destaca por su legibilidad y facilidad de uso. 

	Su enfoque en la simplicidad y su amplia gama de aplicaciones lo convierten en una herramienta valiosa para una variedad de proyectos, desde desarrollo web hasta análisis de datos y más.




|| VERSIONES  

	Cada versión de Python trae consigo nuevas funcionalidades, mejoras de rendimiento y correcciones de errores. 

	Es fundamental mantenerse actualizado con las versiones más recientes para aprovechar las ventajas de seguridad y funcionalidad que ofrece el lenguaje.


	Python 1.x: 

		Las primeras versiones de Python, como 1.0 y 1.5, se lanzaron en la década de 1990. 

		Estas versiones iniciales establecieron los fundamentos del lenguaje y establecieron la base para su desarrollo futuro.


    Python 2.x: 

    	Esta serie incluye versiones como 2.0, 2.7, etc. Python 2.x fue ampliamente utilizado y popular durante muchos años. 

    	Sin embargo, en 2008, se anunció que Python 2.x dejaría de recibir soporte oficial después del 2020. 

    	La transición de Python 2.x a Python 3.x tomó tiempo debido a algunas diferencias significativas entre las dos versiones.


    Python 3.x: 

    	Lanzado por primera vez en 2008, Python 3.x introdujo mejoras significativas en el lenguaje. 

    	Se eliminaron algunas características obsoletas y se realizaron cambios para hacer el lenguaje más coherente y más fácil de entender. 

    	Python 3.x se diseñó con la idea de ser más limpio, más eficiente y más orientado al futuro. 

    	La versión más reciente en esta serie es Python 3.9.


    Python 3.10: 

    	A medida que Python continúa evolucionando, nuevas versiones se lanzan periódicamente con mejoras y nuevas características.

    	Python 3.10 es una versión más reciente que sigue mejorando y refinando el lenguaje.


	Es importante tener en cuenta que, con el fin del soporte para Python 2.x, se recomienda encarecidamente usar Python 3.x para cualquier proyecto nuevo. 

	La comunidad y los desarrolladores han migrado en gran medida a Python 3.x debido a sus mejoras y la falta de soporte para nuevas versiones de Python 2.x.


	Funcionalidades agregadas: 

		Python 3.0 (2008):

		    Introducción de la división de enteros por defecto. 

		    En Python 2.x, la división de enteros generaba otro entero.

		    En Python 3.x, la división de enteros genera un número de punto flotante por defecto.

		    Eliminación de algunas características obsoletas.

		    Mejora en la manipulación de cadenas y Unicode.

		    Introducción de funciones generadoras y expresiones generadoras.

		    Cambios en la impresión de cadenas (se introdujo la función print() con paréntesis).

		    Nueva sintaxis para el manejo de excepciones.


		Python 3.1 (2009):

		    Mejoras en la velocidad y optimización del intérprete.

		    Agregación de nuevos módulos y bibliotecas.

		    Mejoras en el manejo de excepciones.

		    Nueva sintaxis para decoradores.


		Python 3.2 (2011):

		    Mejoras en la biblioteca estándar.

		    Introducción de la función 'functools.lru_cache()' para cachear resultados de funciones.

		    Introducción de la sintaxis 'with' para la gestión de contextos.


		Python 3.3 (2012):

		    Introducción de la sintaxis 'yield from' para simplificar el uso de generadores anidados.

		    Agregación del módulo 'venv' para la creación de entornos virtuales.

		    Mejoras en el rendimiento y la eficiencia.

		    Nuevas características en la biblioteca estándar.


		Python 3.4 (2014):

		    Introducción del módulo 'asyncio' para programación asíncrona.

		    Incorporación del decorador '@asyncio.coroutine' para definir generadores asincrónicos.

		    Adición de un nuevo operador de matriz '@' para multiplicación de matrices.

		    Mejoras en la biblioteca estándar y correcciones de errores.


		Python 3.5 (2015):

		    Introducción de la palabra clave 'await' para la programación asincrónica.

		    Adición de la expresión 'async def'para definir funciones asincrónicas.

		    Incorporación de la biblioteca typing para anotaciones de tipos.

		    Mejoras en la sintaxis y rendimiento.


		Python 3.6 (2016):

		    Introducción del operador de formateo de cadenas 'f-strings'.

		    Adición de la biblioteca 'secrets' para la generación segura de números aleatorios y tokens.

		    Introducción de la anotación de tipos en funciones y variables.

		    Agregación del operador de desempaquetado '**' en expresiones.


		Python 3.7 (2018):

		    Introducción de operadores matriciales '@' para multiplicación de matrices y productos escalares.

		    Incorporación del método '__annotations__' para acceder a las anotaciones de tipos.

		    Adición del módulo 'dataclasses' para la creación simplificada de clases de datos.

		    Mejoras en el rendimiento y optimización del intérprete.


		Python 3.8 (2019):

		    Introducción de las expresiones de asignación (:=).

		    Agregación de la característica de "walrus operator" (:=) para asignar y evaluar expresiones en una sola línea.

		    Incorporación del módulo 'math.isqrt()' para cálculos de raíces cuadradas enteras.

		    Mejoras en la sintaxis y la eficiencia.


		Python 3.9 (2020):

		    Introducción de operadores '|' y '|=' para realizar operaciones de unión en diccionarios.

		    Incorporación del operador '|' para realizar operaciones de unión en conjuntos.

		    Agregación de la sintaxis '|=' para actualizar conjuntos y diccionarios.

		    Mejoras en el rendimiento y nuevas características en la biblioteca estándar.



|| EJECUTAR O CORRER PYTHON 
	
	1. Ejecución Interactiva:

		Python ofrece un intérprete interactivo que te permite ejecutar comandos y ver los resultados inmediatamente. 

		Puedes abrir el intérprete interactivo de Python escribiendo "python" en la línea de comandos (en sistemas Unix/Linux) o "python" en el símbolo del sistema (en Windows). 

		Luego, verás el indicador >>>, lo que significa que puedes comenzar a escribir código Python y ver los resultados de inmediato.

		```
			$ python
			Python 3.9.6 (default, Jun 29 2021, 06:20:32)
			[GCC 8.4.0] on linux
			Type "help", "copyright", "credits" or "license" for more information.
			>>>

		```

		Para salir del intérprete, puedes escribir exit() o presionar Ctrl + D (en sistemas Unix/Linux) o Ctrl + Z (en Windows).


	2. Ejecución de Archivos:
		
		Para ejecutar programas Python almacenados en archivos, sigue estos pasos:

    	Crea un archivo con extensión .py usando un editor de texto. 

    	Por ejemplo, puedes usar Notepad en Windows o cualquier editor de texto en otros sistemas.
    
    	Escribe el código Python en el archivo. Por ejemplo, puedes escribir:

    	```python

    		print("Hola, mundo")

    	```

    	Guarda el archivo con un nombre descriptivo y la extensión .py, por ejemplo, mi_programa.py.

	    Abre una ventana del símbolo del sistema (Windows) o terminal (Unix/Linux).

	    Navega al directorio donde guardaste el archivo .py usando el comando cd.

	    Ejecuta el archivo usando el comando python nombre_del_archivo.py. Por ejemplo:

	    ```python

	    	$ python mi_programa.py
			Hola, mundo

	    ```


	3. Ejecución en un entorno de programación:

		Puedes correr Python instalandolo según la forma correspondiente para cada entorno de programación, como pueden ser Visual Studio Code, Sublime y otros parecidos. 



|| SINTAXIS

	
	Comentarios:
		
		Son líneas de texto que se utilizan para agregar explicaciones o notas en el código. 

		En Python, los comentarios comienzan con el símbolo #. 

		Todo lo que sigue a # en la misma línea es considerado un comentario y no se ejecutará.

		```python

			# Esto es un comentario
			print("Hola, mundo")  # Esto también es un comentario

		```


	Indentación:
			
		Python utiliza la indentación (espacios o tabulaciones) para delimitar bloques de código en lugar de utilizar llaves o palabras clave. 

		Los bloques de código deben tener la misma cantidad de indentación.

		```python

			if True:
				print("Este está indentado correctamente")
				print("Este también")

			print("Este no está indentado correctamente")  # Generará un error

		```


	Variables y Asignación:
		
		En Python, puedes asignar valores a variables utilizando el operador =. 

		No es necesario declarar el tipo de variable.

		````python

			mensaje = "Hola, Python"
			numero = 42
			decimal = 3.14

		```


	Tipos de Datos:
		
		Python tiene varios tipos de datos incorporados, como cadenas (str), números enteros (int), números de punto flotante (float), listas (list), tuplas (tuple), conjuntos (set), diccionarios (dict) y más.

		```python

			cadena = "Hola, Python"
			entero = 42
			decimal = 3.14
			lista = [1, 2, 3]
			tupla = (4, 5, 6)
			conjunto = {7, 8, 9}
			diccionario = {"clave": "valor"}

		```


	Entrada y Salida:
		
		Puedes usar la función input() para recibir datos del usuario y la función print() para mostrar información en la pantalla.

		```python

			nombre = input("Ingresa tu nombre: ")
			print("Hola,", nombre)

		```


	Estructuras de Control:

		Python utiliza las estructuras de control if, elif y else para tomar decisiones, y bucles for y while para realizar iteraciones.

		```python

			if edad < 18:
			    print("Eres menor de edad")
			elif edad >= 18:
			    print("Eres mayor de edad")
			else:
			    print("Edad desconocida")

			for i in range(5):
			    print(i)

			while contador < 10:
			    print(contador)
			    contador += 1

		```



|| VARIABLES 

	Son contenedores utilizados para almacenar valores en Python.


	Declaración y Asignación:
		
		En Python, no es necesario declarar explícitamente el tipo de variable antes de usarla.

		Simplemente asigna un valor a una variable utilizando el operador de asignación '='.

		```python

			nombre = "Alice"  # Asigna una cadena a la variable "nombre"
			
			edad = 25  # Asigna un número entero a la variable "edad"
			
			altura = 1.75  # Asigna un número de punto flotante a la variable "altura"

		```


	Nombres de Variables:
		
		Los nombres de variables en Python deben seguir ciertas reglas:

			Deben comenzar con una letra (mayúscula o minúscula) o con un guión bajo (_).

			Pueden contener letras, números y guiones bajos.

			Los nombres distinguen entre mayúsculas y minúsculas (por ejemplo, nombre y Nombre son diferentes).

			```python

				nombre = "Alice"  # Correcto
				Nombre = "Bob"  # Correcto, pero distinto de "nombre"
				_ultimo_nombre = "Smith"  # Correcto
				1edad = 25  # Incorrecto, no puede comenzar con un número

			```


	Tipos de Variables:
		
		Las variables en Python pueden contener diferentes tipos de valores, como cadenas, números enteros, números de punto flotante, listas, etc.

		```python

			nombre = "Alice"  # Cadena
			edad = 25  # Entero
			altura = 1.75  # Punto flotante
			numeros = [1, 2, 3, 4]  # Lista

		```


	Reasignación:
		
		Puedes cambiar el valor de una variable en cualquier momento reasignándole un nuevo valor.

		```python

			edad = 25
			print(edad)  # Imprimirá 25

			edad = 30
			print(edad)  # Imprimirá 30

		```


	Operaciones con Variables:
		
		Puedes realizar operaciones matemáticas y manipulaciones con variables.

		```python

			x = 5
			y = 3
			suma = x + y  # Suma de variables
			producto = x * y  # Multiplicación de variables

			nombre = "Alice"
			saludo = "Hola, " + nombre  # Concatenación de cadenas

		```

	Convenciones de Nombres:
		
		Se recomienda seguir convenciones de nombres para hacer el código más legible:

    		Utiliza nombres en minúsculas para las variables (nombre, edad).
    	
    		Si el nombre consta de varias palabras, sepáralas con guiones bajos (nombre_completo, puntos_totales).

    		Evita nombres que puedan confundirse con palabras clave de Python (if, while, etc.).	


    Alcance de Variables:
		
		El alcance de una variable es la parte del programa donde esa variable es visible y puede ser utilizada. 

		Las variables pueden tener alcance global (en todo el programa) o alcance local (limitado a una función o bloque).

		```python

			variable_global = 10  # Variable global

			def mi_funcion():
			    variable_local = 5  # Variable local
			    print(variable_global)  # Puedo acceder a una variable global aquí

			print(variable_global)  # Puedo acceder a una variable global aquí
			print(variable_local)  # Esto generará un error, la variable local no es visible aquí

		```



|| TIPOS DE DATOS
	
	Los tipos de datos en Python definen el tipo de valor que una variable puede contener. 

	Python tiene varios tipos de datos incorporados, cada uno con sus propias características y operaciones.
	

	Cadena (str):
		
		Las cadenas son secuencias de caracteres. 

		Pueden contener letras, números, símbolos y espacios. Las cadenas se crean utilizando comillas simples ('...') o comillas dobles ("...").

		```python

			nombre = "Alice"
			mensaje = 'Hola, ¿cómo estás?'

		```


		Inmutabilidad: 

			Las cadenas son inmutables, lo que significa que no puedes modificar sus caracteres directamente después de crearlas. Sin embargo, puedes crear nuevas cadenas basadas en las existentes.


		Longitud: 

			Puedes obtener la longitud de una cadena utilizando la función incorporada len().

			```python

				mensaje = "Hola, mundo"
			longitud = len(mensaje)  # Devuelve 11

				```


		Concatenación: 

			Puedes concatenar cadenas utilizando el operador +.

			```python

				saludo = "Hola, "
			nombre = "Alice"	
			mensaje = saludo + nombre  # Devuelve "Hola, Alice"

			```	


		Indexación y Segmentación:

			Puedes acceder a caracteres individuales de una cadena utilizando índices. 

			La indexación comienza desde 0.

			```python

				palabra = "Python"
			primer_caracter = palabra[0]  # Devuelve "P"

			```

			Puedes segmentar (cortar) cadenas para obtener subcadenas.

			```python

				mensaje = "Hola, mundo"	
			
			subcadena = mensaje[0:5]  # Devuelve "Hola,"

			```

   		Metodos: 
   			
   			.lower(): Convierte la cadena en minúsculas.

			.upper(): Convierte la cadena en mayúsculas.

			.strip(): Elimina espacios en blanco al principio y al final de la cadena.

			.split(): Divide la cadena en una lista de subcadenas usando un delimitador.

			.replace(): Reemplaza una subcadena con otra.

			```python

				texto = "Hola, Mundo"
				texto_min = texto.lower()  # "hola, mundo"
				texto_may = texto.upper()  # "HOLA, MUNDO"

			```


		Formateo de Cadenas:	
		
			Puedes formatear cadenas utilizando literales de cadena f (f-strings) o el método .format().

			```python

				nombre = "Alice"
				edad = 30
				saludo = f"Hola, {nombre}. Tienes {edad} años."

			```

			```python

				nombre = "Alice"
				edad = 30
				saludo = "Hola, {}. Tienes {} años.".format(nombre, edad)

			```


		Comprobación de Contenido:
			
			Puedes verificar si una subcadena está presente en una cadena utilizando los operadores in y not in.

			```python

				mensaje = "Hola, mundo"
				
				if "mundo" in mensaje:
				    print("La subcadena 'mundo' está presente.")

			```


	Números (int y float):
		
		Los números en Python pueden ser enteros (int) o de punto flotante (float).		

		```python

			entero = 42
			decimal = 3.14

		```

		Puedes realizar operaciones matemáticas con números, como suma, resta, multiplicación y división.


		Operaciones Aritméticas: 

			Los números en Python admiten operaciones aritméticas básicas, como suma, resta, multiplicación y división.

			```python

				a = 5
				b = 3

				suma = a + b  # Suma: 8
				resta = a - b  # Resta: 2
				multiplicacion = a * b  # Multiplicación: 15
				division = a / b  # División: 1.666...

			```


		Precisión de Punto Flotante: 
		
			Los números de punto flotante (float) pueden representar números reales, pero pueden tener limitaciones de precisión debido a la representación binaria.	

			```python

				x = 0.1 + 0.1 + 0.1  # Puede no ser exactamente 0.3 debido a la precisión de punto flotante

			```


		Modulo math: 

			Admite operaciones matemáticas más avanzadas utilizando funciones incorporadas del módulo 

			```python

				import math

				raiz_cuadrada = math.sqrt(16)  # Raíz cuadrada: 4.0
				potencia = math.pow(2, 3)  # Potencia: 8.0

			```


		Redondeo y Truncamiento: 

			Puedes redondear números utilizando las funciones incorporadas round(), math.floor() y math.ceil().

			```python

				x = 3.7
				redondeado = round(x)  # Redondeo: 4
				truncado = math.floor(x)  # Truncamiento: 3

			```


		Conversiones de Tipo: 

			Puedes convertir números de un tipo a otro utilizando funciones incorporadas, como int() y float().

			```python

				entero = int(5.3)  # Conversión a entero: 5
				decimal = float(10)  # Conversión a decimal: 10.0

			```


		Operadores Numéricos Especiales: 

			Python también proporciona operadores especiales para realizar divisiones enteras y obtener el resto.

			```python

				division_entera = 7 // 3  # División entera: 2
				resto = 7 % 3  # Resto: 1

			```


		Comparaciones Numéricas: 

			Puedes comparar números utilizando operadores de comparación como <, >, <=, >=, == y !=.

			```python

				a = 5
				b = 3

				es_mayor = a > b  # Verdadero
				es_igual = a == b  # Falso

			```


	Listas (list):
		
		Las listas son colecciones o secuencias ordenadas de elementos mutables. 

		Pueden contener elementos de diferentes tipos.

		```python

			numeros = [1, 2, 3, 4]
			nombres = ["Alice", "Bob", "Charlie"]

		```	

		Puedes acceder a elementos individuales de una lista utilizando índices y realizar diversas operaciones como agregar elementos, eliminar elementos y modificar elementos existentes.


	    Orden: 

	    	Los elementos en una lista están ordenados y se almacenan en posiciones específicas. 

	    	Puedes acceder a elementos individuales utilizando índices.

	    	```python

	    		numeros = [1, 2, 3, 4]
				primer_numero = numeros[0]  # Devuelve 1

	    	```


	    Mutabilidad: 

	    	Las listas son mutables, lo que significa que puedes modificar, agregar y eliminar elementos después de crear la lista.


		Agregar Elementos:

			Puedes agregar elementos a una lista utilizando el método .append() o la concatenación.

			```python

				frutas = ["manzana", "banana", "naranja"]
				frutas.append("kiwi")  # Agrega "kiwi" al final de la lista


			```
		

		Modificar Elementos: 

			Puedes modificar elementos en una lista utilizando índices.

			```python

				numeros = [1, 2, 3, 4]
				numeros[1] = 5  # Cambia el segundo elemento a 5

			```


		Eliminar Elementos: 

			Puedes eliminar elementos de una lista utilizando los métodos .remove() y .pop().

			```python

				colores = ["rojo", "verde", "azul"]
				colores.remove("verde")  # Elimina "verde" de la lista
				ultimo_color = colores.pop()  # Elimina el último elemento y lo devuelve

			```


    	Operaciones de Lista: 

    		Python proporciona una variedad de operaciones incorporadas para trabajar con listas, como:

		    .len(): Devuelve la longitud de la lista.

		    .count(): Cuenta cuántas veces aparece un elemento en la lista.

		    .index(): Encuentra el índice de un elemento en la lista.

		    ```python

		    	numeros = [1, 2, 3, 2, 4, 5, 2]
				longitud = len(numeros)  # Devuelve 7
				veces_dos_aparece = numeros.count(2)  # Devuelve 3
				indice_cuatro = numeros.index(4)  # Devuelve 4

		    ```


		Ordenar y Revertir: 
		
			Puedes ordenar una lista con el método .sort() y revertir el orden con el método .reverse().   

			```python

				numeros = [4, 1, 3, 2]
				numeros.sort()  # Ordena la lista en orden ascendente
				numeros.reverse()  # Revierte el orden de la lista

			```


		Segmentación de Listas:

			Puedes segmentar (cortar) una lista para obtener sublistas.

			```python

				frutas = ["manzana", "banana", "naranja", "kiwi"]
				subfrutas = frutas[1:3]  # Devuelve ["banana", "naranja"]

			```


	Tuplas (tuple):
		
		Las tuplas son similares a las listas, pero son inmutables, lo que significa que no puedes cambiar sus elementos después de crearlas.

		```python

			coordenadas = (3, 5)
			dias_semana = ("Lunes", "Martes", "Miércoles")

		```


		Inmutabilidad: 

			A diferencia de las listas, las tuplas no se pueden modificar después de crearlas. 

			Una vez que creas una tupla, no puedes agregar, modificar o eliminar elementos.


		Orden: 

			Los elementos en una tupla están ordenados y se almacenan en posiciones específicas. 

			Puedes acceder a elementos individuales utilizando índices


			```python

				coordenadas = (3, 5)
				primer_elemento = coordenadas[0]  # Devuelve 3

			```


		Indexación y Segmentación:

			Al igual que las listas, puedes acceder a elementos individuales de una tupla utilizando índices. 

			También puedes segmentar (cortar) tuplas para obtener sub-tuplas.

			```python

				mi_tupla = (1, 2, 3, 4, 5)
				primer_elemento = mi_tupla[0]  # Devuelve 1
				sub_tupla = mi_tupla[1:3]  # Devuelve (2, 3)

			```


		Desempaquetado de Tuplas: 

			Puedes asignar elementos individuales de una tupla a variables utilizando el desempaquetado de tuplas.

			```python

				punto = (3, 5)
				x, y = punto  # x será 3, y será 5

			```


		Concatenación y Repetición: 	

			Puedes concatenar tuplas utilizando el operador +. También puedes repetir una tupla utilizando el operador *.

			```python

				tupla1 = (1, 2)
				tupla2 = (3, 4)
				tupla_concatenada = tupla1 + tupla2  # Devuelve (1, 2, 3, 4)
				tupla_repetida = tupla1 * 3  # Devuelve (1, 2, 1, 2, 1, 2)

			```


		Funciones de Tupla: 

			Python proporciona funciones incorporadas que trabajan con tuplas, como len(), min(), max() y sum().

			```python

				mi_tupla = (10, 5, 7, 3)
				longitud = len(mi_tupla)  # Devuelve 4
				valor_minimo = min(mi_tupla)  # Devuelve 3
				valor_maximo = max(mi_tupla)  # Devuelve 10
				suma = sum(mi_tupla)  # Devuelve 25

			```

			Son útiles cuando deseas crear una colección de elementos que no deberían cambiar después de su creación. 

			Se utilizan en situaciones donde la inmutabilidad es deseable, como para representar coordenadas, nombres de meses, puntos de datos fijos, etc.


	Conjuntos (set):
		
		Los conjuntos son colecciones no ordenadas de elementos únicos.

		```python

			frutas = {"manzana", "banana", "naranja"}

		```

		Son útiles para realizar operaciones de conjuntos como unión, intersección y diferencia.


		Elementos Únicos: 

			Los conjuntos no pueden contener elementos duplicados. 

			Si intentas agregar un elemento que ya está en el conjunto, no se agregará nuevamente.

			```python

				frutas = {"manzana", "banana", "naranja", "banana"}  # "banana" solo aparece una vez en el conjunto

			```


		No tienen Orden: 

			Los elementos en un conjunto no tienen un orden específico. 

			No puedes acceder a elementos individuales mediante índices.


		Agregar y Eliminar Elementos: 		
			Puedes agregar elementos a un conjunto utilizando el método .add() y eliminar elementos utilizando el método .remove().

			```python

				colores = {"rojo", "verde", "azul"}
				colores.add("amarillo")  # Agrega "amarillo" al conjunto
				colores.remove("verde")  # Elimina "verde" del conjunto

			```


		Comprobación de Pertenencia: 

			Puedes verificar si un elemento está presente en un conjunto utilizando el operador in.

			```python

				frutas = {"manzana", "banana", "naranja"}
				if "banana" in frutas:
    				print("Banana está en el conjunto.")

			```


		Operaciones de Conjuntos: 

			Python proporciona una variedad de operaciones incorporadas para trabajar con conjuntos, como:

		    .union(): Realiza la unión de dos conjuntos.

		    .intersection(): Realiza la intersección de dos conjuntos.

		    .difference(): Calcula la diferencia entre dos conjuntos.

		    .issubset(): Comprueba si un conjunto es un subconjunto de otro.

		    .issuperset(): Comprueba si un conjunto es un superconjunto de otro.

		    ```python

		    	conjunto1 = {1, 2, 3}
				conjunto2 = {3, 4, 5}
				union = conjunto1.union(conjunto2)  # Devuelve {1, 2, 3, 4, 5}
				interseccion = conjunto1.intersection(conjunto2)  # Devuelve {3}

		    ```


		Operaciones de Conjunto Modificadas: 

			Además de los métodos mencionados anteriormente, Python también proporciona versiones modificadas de estos métodos, como .update(), .intersection_update(), .difference_update(), que modifican el conjunto en lugar de crear uno nuevo.

			```python

				conjunto1 = {1, 2, 3}
				conjunto2 = {3, 4, 5}
				conjunto1.update(conjunto2)  # Modifica conjunto1 a {1, 2, 3, 4, 5}

			```




	Diccionarios (dict):
		
		Los diccionarios son colecciones de pares clave-valor. 

		Cada valor está asociado con una clave única.

		```python

			persona = {"nombre": "Alice", "edad": 25, "altura": 1.75}

		```

		Puedes acceder a valores utilizando claves y realizar operaciones como agregar nuevos pares clave-valor, modificar valores y eliminar entradas.


		Pares Clave-Valor: 

			Los diccionarios almacenan elementos como pares clave-valor, donde cada clave es única y está asociada con un valor específico.

			```python

				persona = {"nombre": "Alice", "edad": 30, "ciudad": "Nueva York"}

			```


		Mutabilidad: 

			Los diccionarios son mutables, lo que significa que puedes agregar, modificar y eliminar elementos después de crear el diccionario.


		Acceso a Valores: 

			Puedes acceder a valores en un diccionario utilizando las claves correspondientes.

			```python

				persona = {"nombre": "Alice", "edad": 30}
				nombre = persona["nombre"]  # Devuelve "Alice"

			```


		Modificación y Adición de Elementos: 

			Puedes modificar valores existentes en un diccionario y también agregar nuevos pares clave-valor.

			
			```python

				persona = {"nombre": "Alice", "edad": 30}
				persona["edad"] = 31  # Modifica el valor de "edad"
				persona["ciudad"] = "Nueva York"  # Agrega un nuevo par clave-valor

			```


		Eliminación de Elementos: 

			Puedes eliminar elementos de un diccionario utilizando la instrucción del o el método .pop().

			```python

				persona = {"nombre": "Alice", "edad": 30}
				del persona["edad"]  # Elimina el par clave-valor "edad"
				ciudad = persona.pop("ciudad")  # Elimina y devuelve el valor asociado a "ciudad"

			```

		
		Verificación de Existencia de Claves: 

			Puedes verificar si una clave específica existe en un diccionario utilizando el operador in.

			```python

				persona = {"nombre": "Alice", "edad": 30}
				if "nombre" in persona:
				    print("La clave 'nombre' existe en el diccionario.")

			```			


		Obtención de Claves y Valores: 

			Puedes obtener una lista de todas las claves o valores en un diccionario utilizando los métodos .keys() y .values() respectivamente.

			```python

				persona = {"nombre": "Alice", "edad": 30}
				claves = persona.keys()  # Devuelve ["nombre", "edad"]
				valores = persona.values()  # Devuelve ["Alice", 30]

			```


		Obtención de Pares Clave-Valor: 	
			Puedes obtener una lista de tuplas que contienen pares clave-valor utilizando el método .items().

			```python

				persona = {"nombre": "Alice", "edad": 30}
				pares = persona.items()  # Devuelve [("nombre", "Alice"), ("edad", 30)]

			```


	Booleanos (bool):
		
		Los booleanos representan valores de verdadero (True) o falso (False). 

		Se utilizan en expresiones de control de flujo y para tomar decisiones.

		```python

			verdadero = True
			falso = False

		```


		Valores Constantes: 

			Los valores booleanos solo pueden ser True o False, que son constantes incorporadas en Python.


    	Operaciones de Lógica: 

    		Los valores booleanos son fundamentales para las operaciones lógicas como la negación (not), la conjunción (and) y la disyunción (or).


			```python

				a = True
				b = False

				negacion_a = not a  # Falso
				conjuncion = a and b  # Falso
				disyuncion = a or b  # Verdadero

			```


    	Comparaciones: 

    		Puedes realizar comparaciones entre valores utilizando operadores de comparación como == (igual), != (distinto), < (menor que), > (mayor que), <= (menor o igual que), >= (mayor o igual que).

    		```python

    			x = 5
				y = 10
				es_igual = x == y  # Falso
				es_menor = x < y  # Verdadero

    		```


		Comprobación de Pertinencia: 

			Puedes verificar si un valor está contenido en una colección utilizando el operador in.    		

			```python

				numeros = [1, 2, 3, 4, 5]
				tiene_tres = 3 in numeros  # Verdadero

			```


		Control de Flujo: 

			Los valores booleanos se utilizan para controlar el flujo de ejecución en estructuras de control condicionales como if, elif y while.

			```python

				edad = 18
				if edad >= 18:
				    print("Eres mayor de edad")
				else:
				    print("Eres menor de edad")

			```


		Funciones que Retornan Valores Booleanos: 

			Muchas funciones incorporadas en Python retornan valores booleanos para indicar si una condición se cumple. 

			Por ejemplo, el método .startswith() de las cadenas devuelve True si la cadena comienza con una subcadena específica.

			```python

				mensaje = "Hola, mundo"
				comienza_con_hola = mensaje.startswith("Hola")  # Verdadero

			```


		Conversión desde Otros Tipos:

			Puedes convertir otros tipos de datos a valores booleanos utilizando la función incorporada bool(). 

			Cualquier valor numérico diferente de cero o cualquier cadena no vacía se convierte en True, mientras que el valor numérico cero o una cadena vacía se convierten en False.

			```python

				valor_entero = 5
				valor_booleano = bool(valor_entero)  # Verdadero

				cadena_vacia = ""
				valor_booleano2 = bool(cadena_vacia)  # Falso

			```


	None:
		
		None es un tipo de dato especial que representa la ausencia de valor. 

		Se utiliza comúnmente para indicar que una variable no tiene un valor asignado.

		```python

			resultado = None

		```	


		Valor Único: 

			El valor None es único y no se puede comparar con otros valores de manera significativa. 

			No es igual a ningún otro valor, incluyendo otros valores None.	

			```python

				x = None
				y = None
				es_igual = x == y  # Verdadero

			```


		No es Falso: 

			Aunque None se evalúa como falso en contextos booleanos, no es igual a False. 

			Es importante recordar que None representa la ausencia de valor, no el valor booleano falso.


		Asignación Inicial: 

			A menudo, None se utiliza para inicializar variables antes de asignarles un valor específico.

			```python

				resultado = None

			```


		Valor de Retorno Predeterminado: 

			Las funciones pueden tener un valor de retorno predeterminado de None. 

			Si no se especifica un valor de retorno, la función devolverá automáticamente None.

			```python

				def funcion_vacia():
			    pass  # No tiene un return, por lo tanto, retorna None automáticamente

			```

		
		Comprobación de Valores Nulos: 

			Se utiliza para comprobar si una variable o una expresión no contiene un valor asignado. 

			Esto puede ser útil para evitar errores en casos donde se espera un valor pero no se tiene uno.

			```python

				resultado = realizar_alguna_operacion()
				if resultado is None:
				    print("La operación no produjo un resultado válido.")

			```


		Comparación con is: 

			En lugar de usar el operador de igualdad (==) para verificar si algo es None, es preferible usar el operador is.

			```python

				valor = None
				if valor is None:
				    print("El valor es None.")

			```


		Funciones que No Retornan Valores: 

			Las funciones que no tienen una instrucción de retorno (o que solo contienen return sin argumentos) retornarán implícitamente None.	

			```python

				def funcion_sin_retorno():
				    print("Esta función no retorna nada.")

				resultado = funcion_sin_retorno()  # resultado será None

			```



|| CONDICIONALES O COMPARADORES

	Son operadores que se utilizan para comparar dos valores y evaluar condiciones.

	Se utilizan en estructuras de control como declaraciones if, bucles while y for, y expresiones condicionales.

	Al combinarlos con operadores lógicos (and, or, not), puedes crear condiciones más complejas para controlar el flujo de tu programa y tomar decisiones fundamentadas en diferentes situaciones.


	Valores de Comparación: 

		Los comparadores toman dos valores y los comparan para determinar la relación entre ellos. 

		Los valores pueden ser variables, constantes o expresiones.


    Resultados Booleanos: 

    	Los comparadores siempre devuelven un valor booleano, es decir, True (verdadero) o False (falso), dependiendo del resultado de la comparación.


    Igual (==): 

    	Compara si dos valores son iguales.

    	```python

    		x = 5
			y = 5
			resultado = x == y  # Devuelve True

    	```


   Distinto (!=): 

   	Compara si dos valores son diferentes.

   	```python

   		x = 5
		y = 10
		resultado = x != y  # Devuelve True

   	```


    Mayor que (>): 

    	Compara si el valor de la izquierda es mayor que el valor de la derecha.

    	```python

    		x = 10
			y = 5
			resultado = x > y  # Devuelve True

    	```


	Menor que (<): 

		Compara si el valor de la izquierda es menor que el valor de la derecha. 
		

		```python

			x = 5
			y = 10
			resultado = x < y  # Devuelve True

		```   


	Mayor o igual que (>=): 

		Compara si el valor de la izquierda es mayor o igual al valor de la derecha.

		```python

			x = 10
			y = 5
			resultado = x >= y  # Devuelve True

		```


	Menor o igual que (<=): 

		Compara si el valor de la izquierda es menor o igual al valor de la derecha.

		```python

			x = 5
			y = 10
			resultado = x <= y  # Devuelve True

		```



|| CONVERSIÓN DE TIPOS DE DATOS

	"Type Conversion" o "Casting", se refiere al proceso de cambiar el tipo de un objeto de datos de un tipo a otro. 

	Esto es útil cuando necesitas operar o trabajar con valores de diferentes tipos en una expresión o en una operación específica.


	Implicit Type Casting (Casting Implícito): 

		También conocido como "coerción", ocurre automáticamente cuando Python convierte automáticamente un tipo de dato en otro para realizar una operación. 

		Por ejemplo, cuando sumas un entero con un número de punto flotante, Python convierte automáticamente el entero en un flotante para realizar la operación.

		```python

			x = 5         # int
			y = 2.5       # float
			resultado = x + y  # Aquí ocurre un casting implícito de int a float

		```


	Explicit Type Casting (Casting Explícito): 

		Esto implica cambiar deliberadamente el tipo de un objeto de datos utilizando funciones incorporadas. 

		Al hacer esto, tienes un mayor control sobre cómo se realiza la conversión y puedes evitar errores inesperados.


	int(): Convierte un valor a un entero.

    float(): Convierte un valor a un número de punto flotante.

    str(): Convierte un valor a una cadena.

    bool(): Convierte un valor a un valor booleano.

    list(): Convierte un valor a una lista.

    tuple(): Convierte un valor a una tupla.

    ```python

    	valor_entero = 5
		valor_flotante = float(valor_entero)  # Convierte a float

		cadena_numero = "10"
		valor_entero_desde_cadena = int(cadena_numero)  # Convierte a int

		booleano = bool(1)  # Convierte a True, ya que 1 es considerado verdadero

    ```

    No todas las conversiones de tipo son válidas. 

    Por ejemplo, no puedes convertir una cadena que no represente un número en un entero o flotante. 

    Si intentas realizar una conversión que no es posible, Python arrojará una excepción llamada ValueError.

    Útil para manipular datos y asegurarse de que estás operando con los tipos de datos correctos en diferentes situaciones. 

    Sin embargo, es importante usarlo con precaución y asegurarse de que las conversiones sean apropiadas para evitar errores y comportamientos inesperados en tu código.
  	  


|| EXCEPCIONES 

	Conocidas como "errores" o "excepciones de error" son eventos que ocurren durante la ejecución de un programa y que interrumpen el flujo normal del programa debido a situaciones inesperadas o no manejadas. 

	Cuando una excepción se produce, el programa normalmente se detiene y el control se transfiere a un bloque de código diseñado para manejar la excepción.

	Permiten a los programadores manejar situaciones de error de manera elegante y controlada, en lugar de que el programa simplemente se detenga con un mensaje de error o se cierre abruptamente en caso de problemas.


	Lanzamiento de Excepciones: 

		Cuando ocurre una situación excepcional en el código, como una división por cero o el acceso a una variable que no está definida, Python lanza una excepción específica para esa situación.


    Captura de Excepciones: 

    	Puedes usar bloques try y except para capturar excepciones y manejarlas de manera adecuada. 

    	El bloque try contiene el código que podría causar una excepción, y el bloque except contiene el código que se ejecutará si se lanza una excepción.


    ```python

    	try:
	    numero = 10 / 0  # Intenta dividir por cero, lo cual lanza una excepción
		except ZeroDivisionError:
		    print("Error: División por cero")

    ```

    Manejo de Varios Tipos de Excepciones: 

    	Puedes manejar diferentes tipos de excepciones en bloques except separados para realizar acciones específicas según el tipo de error.

    	```python

    		try:
			    valor = int("texto")  # Intenta convertir una cadena no numérica a entero
			except ValueError:
			    print("Error: Valor no numérico")
			except TypeError:
			    print("Error: Tipo incorrecto")

    	```


    Bloque else: 

    	Puedes usar un bloque else después del bloque try y except para ejecutar código si no se produce ninguna excepción.

    	```python

    		try:
			    archivo = open("archivo.txt", "r")
			except FileNotFoundError:
			    print("Error: El archivo no existe")
			else:
			    contenido = archivo.read()
			    archivo.close()

    	```


    Bloque finally: 

    	Puedes usar un bloque finally después de un bloque try y except para ejecutar código que siempre debe ejecutarse, independientemente de si se lanzó una excepción o no.

    	```python

    		try:
			    # Código que puede lanzar una excepción
			except SomeException:
			    # Manejo de la excepción
			finally:
			    # Código que siempre se ejecutará

    	```



|| FUNCIONES 

	Se utilizan en una variedad de casos para organizar, reutilizar y simplificar el código.


	Reutilización de Código: 

		Una de las principales ventajas de las funciones es la reutilización de código. 

		Puedes definir una función una vez y llamarla en múltiples lugares del programa, lo que evita la duplicación de código.


    Abstracción: 

    	Las funciones permiten abstraer detalles complejos. 

    	Puedes encapsular un conjunto de instrucciones complejas en una función con un nombre descriptivo, lo que facilita la lectura y comprensión del código.


    Modularidad: 

    	Divide tu código en módulos más pequeños y manejables. 

    	Cada función realiza una tarea específica, lo que facilita la organización del código y el mantenimiento a medida que el programa crece.


    Encapsulación: 

    	Puedes ocultar la implementación interna de una función y solo proporcionar una interfaz pública. 

    	Esto mejora la seguridad y evita que otros desarrolladores accedan directamente a partes internas del código.


    Legibilidad: 

    	Usar funciones con nombres descriptivos mejora la legibilidad del código, ya que comunica la intención y funcionalidad de manera clara.


    Debugging y Mantenimiento: 

    	Si encuentras un error en una función, solo necesitas corregirlo en un lugar. 

    	Esto evita la necesidad de cambiarlo en múltiples partes del programa.


    Manejo de Excepciones: 

    	Las funciones pueden encapsular bloques de código que podrían generar excepciones y manejar esas excepciones de manera centralizada.


    Programación Modular: 

    	En proyectos grandes, puedes dividir tareas complejas en funciones más pequeñas y luego combinar esas funciones para lograr la funcionalidad deseada.


    Funciones Matemáticas: 

    	Las funciones son útiles para encapsular fórmulas matemáticas o cálculos repetitivos.


    Interacción con Archivos y Red: 	

    	Puedes encapsular la lógica de interacción con archivos, bases de datos o redes en funciones para facilitar el manejo de datos.


    Transformación de Datos: 

    	Las funciones son útiles para transformar datos en diferentes formatos o realizar operaciones específicas en conjuntos de datos.


    Interfaz de Usuario: 

    	En aplicaciones, puedes usar funciones para encapsular la lógica de la interfaz de usuario, como la validación de entradas.


    Procesamiento de Texto: 

    	Funciones para el procesamiento de cadenas, como dividir, unir y reemplazar texto.


    Ejemplos: 

    	```python

    		# Definición de una función simple
			def saludar(nombre):
			    """
			    Esta función saluda a la persona cuyo nombre se proporciona.
			    """
			    print("Hola,", nombre)

    		# Llamada a la función
			saludar("Alice")  # Salida: Hola, Alice

			# Función con valor de retorno
			def sumar(a, b):
			    """
			    Esta función suma dos números y retorna el resultado.
			    """
			    resultado = a + b
			    return resultado
    	```


|| FUNCIÓN ANÓNIMA
	
	En Python se llaman "funciones lambda". 

	Son funciones pequeñas y anónimas que se pueden definir en una sola línea de código. 

	A diferencia de las funciones normales definidas con la palabra clave def, las funciones lambda no tienen un nombre asociado y se utilizan en situaciones donde necesitas una función simple para una tarea específica.

	Son limitadas en cuanto a su complejidad y funcionalidad en comparación con las funciones definidas con def. 

	Por lo tanto, se recomienda usarlas principalmente para tareas pequeñas y simples.

	```python

		lambda argumentos: expresion

	```

	lambda: 

		Es la palabra clave que indica que estás definiendo una función lambda.

    argumentos: 

    	Son los parámetros de entrada de la función lambda, separados por comas.

    expresion: 

    	Es la expresión que se evalúa y se devuelve como resultado de la función.


    ```python

    	# Definición de una función lambda que suma dos números
		sumar = lambda x, y: x + y

		resultado = sumar(5, 3)  # resultado = 8

		# Uso de una función lambda en una función incorporada como sorted()
		numeros = [1, 4, 2, 8, 5]
		numeros_ordenados = sorted(numeros, key=lambda x: x % 2)
		# números_ordenados = [2, 4, 8, 1, 5]

    ```

    En la primera función, 'sumar' es una función lambda que toma dos argumentos x e y, y devuelve su suma.

    La segunda función, se utiliza la función lambda como argumento en la función incorporada sorted() para ordenar una lista de números según su residuo de la división por 2, lo que resulta en una lista con números pares primero y luego los impares.


    Casos de uso: 

    	Ordenamiento Personalizado: 

    		Cuando necesitas ordenar una lista de objetos utilizando un criterio específico, puedes usar una función lambda como argumento en funciones como sorted().


	    Transformación de Datos: 

	    	Cuando deseas aplicar una operación simple a cada elemento de una lista o iterador, como elevar al cuadrado o convertir a mayúsculas.


	    Filtrado de Datos: 

	    	Al filtrar elementos de una lista o iterador basado en una condición específica.


	    Claves de Ordenamiento: 

	    	En situaciones donde necesitas definir una clave de ordenamiento para funciones como sorted() o max().


	    Funciones de Map y Filter: 

	    	En la aplicación de funciones a cada elemento de una lista usando map() o en la filtración de elementos usando filter().


	    Callbacks: 

	    	Cuando se requiere una función para ser pasada como argumento a otra función, como en el caso de funciones de manejo de eventos.


	    Operaciones Matemáticas Simples:

	    	Para operaciones aritméticas o matemáticas simples que se deben aplicar a valores.


	    Validación: 

	    	En la validación de entradas o en la verificación de condiciones específicas.


	    Cálculos de Fórmulas: 

	    	Para cálculos matemáticos o fórmulas simples en situaciones donde no se necesita una función completa.


	    Tratamiento de Strings: 

	    	En operaciones de manipulación de cadenas, como concatenación o formato.


	    Definición de Interfaces de Callback: 

	    	En la definición de interfaces de devolución de llamada en bibliotecas o marcos de trabajo.


	    Operaciones con Listas: 

	    	En la realización de operaciones específicas en listas, como obtener el elemento máximo o mínimo.



|| Función Autoinvocada

	Puedes lograr el mismo efecto utilizando funciones anónimas (lambda) o simplemente llamando a una función inmediatamente después de definirla. 

	Estas técnicas se usan para crear funciones que se ejecutan automáticamente sin necesidad de ser llamadas explícitamente.


	Funciones lambda: 

		Pueden ser invocadas en el mismo momento en que se definen. 

		Son útiles para tareas pequeñas y puntuales.

		```python

			resultado = (lambda x: x * 2)(5)  # resultado = 10

		```

		En este ejemplo, la función lambda se define y se invoca inmediatamente con el valor 5 como argumento.


	Definir y Llamar inmediatamente:

		Puedes definir una función y luego llamarla inmediatamente después de su definición en la estructura del código.

		```python

			def suma(a, b):
			    return a + b

			resultado = suma(3, 4)  # resultado = 7

		```



|| FUNCION RECURSIVA
	
	Son funciones que se llaman a sí mismas para resolver un problema. 

	En esencia, una función recursiva se divide en subproblemas más pequeños del mismo tipo hasta que se alcanza un caso base en el que el problema es lo suficientemente simple para resolverse directamente.
	

	```python

		def funcion_recursiva(parametros):
	    # Caso Base: Condición que detiene la recursión.
	    if condicion_base:
	        return valor_base

	    # Caso Recursivo: Llamada a la función recursiva con argumentos modificados.
	    resultado = funcion_recursiva(parametros_modificados)
	    return resultado

	```

	Caso Base:

		Esta es la condición que detiene la recursión. 

		Cuando se cumple esta condición, la función no se llama a sí misma y devuelve un valor predefinido.

		Sin un caso base adecuado, la función recursiva podría entrar en un bucle infinito.


    Caso Recursivo: 

    	En esta parte, la función se llama a sí misma con argumentos modificados para acercarse al caso base. 

    	La llamada recursiva debe modificar al menos un parámetro de manera que el problema sea más pequeño o más simple en cada iteración.


    Ejemplos: 

    ```python

    	def factorial(n):
	    	# Caso Base: El factorial de 0 es 1.
	    	if n == 0:
	        return 1
	    	# Caso Recursivo: Llamada a la función con n-1.
	    	else:
	        	return n * factorial(n - 1)

		resultado = factorial(5)  # resultado = 120

    ```

    El caso base es cuando n es igual a 0, y la función devuelve 1.

    El caso recursivo es cuando n es mayor que 0, y la función se llama a sí misma con n - 1. Esto se repite hasta que se alcanza el caso base.

	Ten en cuenta que es fundamental que cada llamada recursiva se acerque al caso base para evitar bucles infinitos.


	Casos de uso: 

		Cálculos Matemáticos:

        	Factorial: 

        		Calcular el factorial de un número.

       		Fibonacci: 

       			Generar la secuencia de Fibonacci.

        	Potencia: 

        		Calcular una potencia de un número.

        	Máximo Común Divisor (MCD):
        	 	Encontrar el MCD de dos 	números.


	    Recorrido de Estructuras de Datos:

	        Recorrido de Árboles: 

	        	Explorar árboles binarios o estructuras de árbol más complejas.

	        Recorrido de Grafos: 

	        	Explorar grafos para encontrar caminos o conexiones.

	        Recorrido de Listas Ligadas: 

	        	Navegar por listas ligadas o estructuras de datos similares.


	    Resolución de Problemas Divide y Vencerás:

	        Ordenamiento: 

	        	Algunos algoritmos de ordenamiento, como Quicksort y Mergesort, utilizan recursión.

	        Búsqueda Binaria: 

	        	Buscar elementos en una lista ordenada de manera eficiente.

	        División de Problemas Geométricos: 

	        	Resolver problemas geométricos al dividirlos en subproblemas más pequeños.


	    Tareas Combinatorias:

	        Generación de Permutaciones y Combinaciones: 

	        	Encontrar todas las permutaciones o combinaciones de un conjunto de elementos.


	    Problemas de Juegos y Rompecabezas:

	        Torres de Hanoi: 

	        	Resolver el famoso problema de las Torres de Hanoi.

	        Resolver Sudoku: 

	        	Encontrar soluciones para juegos de Sudoku.


	    Estructuras de Datos Recursivas:

	        Listas Ligadas Recursivas: 

	        	Crear y manipular listas ligadas recursivamente.

	        Árboles Recursivos: 

	        	Implementar estructuras de árboles recursivos.


	    Análisis de Texto:

	        Análisis de Sintaxis: 

	        	Algunos analizadores de lenguaje natural utilizan recursión para analizar la estructura de una oración.


	    Algoritmos de Búsqueda:

	        Búsqueda de Caminos: 

	        	Encontrar caminos en laberintos o mapas.


	    Problemas de Combinatoria:

	        Generación de Subconjuntos:

	        	Encontrar todos los subconjuntos de un conjunto de elementos.



|| FUNCIÓN CLOSURE
	
	Es una función que retiene el entorno léxico en el que se creó, incluso cuando esa función se ejecuta fuera de ese entorno léxico. 

	En otras palabras, un closure permite que una función capture y mantenga las variables locales y parámetros de la función que la rodea, incluso después de que esa función haya terminado su ejecución. 

	Esto permite que la función interna (closure) acceda a esas variables y las utilice más adelante.

	Son útiles cuando deseas tener una función que mantenga ciertos valores o estado específico entre llamadas.

	Esto puede ser especialmente útil en situaciones como la programación asíncrona, la implementación de decoradores y la creación de funciones fábrica.

	```python

		def exterior(x):
		    def interior(y):
		        return x + y
		    return interior

		agregar_5 = exterior(5)
		resultado = agregar_5(3)  # resultado = 8

	```

	exterior() es una función que toma un parámetro x y define una función interna llamada interior(). 

	La función interior() utiliza la variable x del ámbito de exterior() incluso después de que exterior() haya terminado su ejecución. 

	Cuando llamamos a exterior(5), devuelve la función interior() con x establecido en 5. 

	Luego, podemos llamar a agregar_5(3) para agregar 3 al valor capturado de x, lo que resulta en 8.


	Casos de uso teóricos: 

		Encapsulación de Datos Privados:

        	Los closures pueden utilizarse para encapsular variables y métodos dentro de una función, ocultándolos al ámbito global y creando una especie de "clase" con datos privados.


	    Gestión de Memoria y Recursos:
	        
	        En situaciones donde necesitas gestionar la asignación y liberación de recursos, como la apertura y cierre de archivos, los closures pueden garantizar que los recursos se liberen adecuadamente al finalizar una función.


	    Implementación de Singleton:

	        Puedes utilizar un closure para implementar el patrón de diseño Singleton, garantizando que solo haya una instancia de una clase en todo el programa.


	    Factory Functions:

	        Las fábricas de objetos son funciones que crean y devuelven instancias de objetos personalizados. 

	        Los closures pueden ser útiles en la creación de fábricas de objetos con propiedades específicas.


	    Manejo de Estado en UI:

	        En el desarrollo de interfaces de usuario (UI), los closures pueden usarse para administrar el estado de componentes específicos, como ventanas emergentes o diálogos modales.


	    Funciones de Orden Superior:

	        En programación funcional, puedes usar closures para crear funciones de orden superior que toman otras funciones como argumentos y devuelven nuevas funciones con comportamientos personalizados.


	    Seguridad y Aislamiento de Datos:
	        
	        Los closures pueden ayudar a garantizar la seguridad y el aislamiento de datos al limitar el acceso a ciertas variables y funciones dentro de un ámbito cerrado.


	    Manejo de Eventos:

	        En entornos de programación de eventos, los closures pueden utilizarse para definir funciones de manejo de eventos personalizadas que se ejecutan cuando ocurre un evento específico.


	    Optimización de Recursos:

	        Los closures pueden ayudar a optimizar el uso de recursos al garantizar que los recursos se inicialicen solo cuando sea necesario y se liberen cuando ya no se necesiten.


	    Implementación de Lógica de Negocio Específica:

	        En aplicaciones empresariales, los closures pueden ser útiles para implementar lógica de negocio específica que varía según el contexto.


	Casos de uso prácticos: 

		Funciones fábrica: 

			Usar closures para crear funciones personalizadas con parámetros predefinidos. 

			Esto es útil cuando deseas generar funciones con configuraciones específicas.

			```python

				def crear_sumador(x):
				    def sumar(y):
				        return x + y
				    return sumar

				sumar_5 = crear_sumador(5)
				resultado = sumar_5(3)  # resultado = 8

			```

		Decoradores:

			Un decorador es una función que envuelve otra función para agregar funcionalidad. 

			Los closures capturan la función original y la modifican de acuerdo con el decorador.

			```python

				def decorador(funcion):
				    def wrapper(*args, **kwargs):
				        print("Antes de llamar a la función")
				        resultado = funcion(*args, **kwargs)
				        print("Después de llamar a la función")
				        return resultado
				    return wrapper

				@decorador
				def saludar(nombre):
				    return f"Hola, {nombre}!"

				mensaje = saludar("Alice")  # mensaje = "Hola, Alice!"

			```


		Manejo de Estados:

			Pueden usarse para mantener estados o información entre llamadas a una función, sin necesidad de variables globales.

			```python

				def contador_incremetal():
				    contador = 0
				    def incrementar():
				        nonlocal contador
				        contador += 1
				        return contador
				    return incrementar

				contar = contador_incremetal()
				print(contar())  # 1
				print(contar())  # 2

			```


		Funciones de orden superior:

			Permiten crear funciones de orden superior que generan y devuelven otras funciones.

			```python

				def generar_operador(op):
				    def operador(a, b):
				        if op == "+":
				            return a + b
				        elif op == "-":
				            return a - b
				        # Otras operaciones
				    return operador

				suma = generar_operador("+")
				resultado = suma(5, 3)  # resultado = 8

			```

		Manejo de Eventos: 

			En programación de GUI (interfaz gráfica de usuario), los closures se utilizan para manejar eventos específicos, como hacer clic en un botón.

			```python

				from tkinter import Tk, Button

				def crear_handler(mensaje):
				    def handler():
				        print(mensaje)
				    return handler

				root = Tk()
				boton1 = Button(root, text="Clic Me", command=crear_handler("Botón 1 clickeado"))
				boton2 = Button(root, text="Clic Me Too", command=crear_handler("Botón 2 clickeado"))
				boton1.pack()
				boton2.pack()
				root.mainloop()

			```


|| FUNCIÓN CALLBACK

	Es una función que se pasa como argumento a otra función. 

	El concepto es bastante simple pero muy poderoso, ya que te permite definir una parte del comportamiento de un programa y luego pasarlo como entrada a otra parte del código.

	Un ejemplo básico para ilustrar cómo funciona un callback:

		Imagina que tienes una función llamada realizar_operacion que toma dos números y una operación matemática como argumentos y devuelve el resultado de esa operación. 

		En lugar de tener una función separada para cada operación (suma, resta, multiplicación, etc.), puedes usar un callback para pasar la operación como función.

		```python

			def realizar_operacion(a, b, operacion):
			    resultado = operacion(a, b)
			    return resultado

			def suma(x, y):
			    return x + y

			def resta(x, y):
			    return x - y

			resultado1 = realizar_operacion(5, 3, suma)   # resultado1 = 8
			resultado2 = realizar_operacion(5, 3, resta)  # resultado2 = 2

		```

		realizar_operacion es la función principal que realiza una operación en dos números.

		En lugar de tener una función separada para cada operación matemática, puedes pasar la operación como un callback.


	Casos de uso: 

	    Manejo de Eventos de Interfaz de Usuario (UI):

        	En aplicaciones con interfaz de usuario, puedes usar callbacks para manejar eventos como clics de botón, movimientos del mouse o pulsaciones de teclas. Por ejemplo, puedes definir 

        	Una función de callback que se ejecute cuando un usuario hace clic en un botón "Guardar".


		Lectura de Archivos Asíncronos:

		    Al leer archivos de manera asincrónica, puedes utilizar callbacks para especificar qué hacer una vez que se haya completado la lectura del archivo. 

		    Esto es común en entornos web y en la lectura de archivos grandes.


		Peticiones de Red:

		    Al realizar peticiones de red a través de API, puedes usar callbacks para manejar la respuesta una vez que los datos se han recibido. 

		    Esto permite que la aplicación continúe funcionando mientras espera la respuesta del servidor.


		Temporizadores y Retrasos:

		    Puedes usar callbacks para ejecutar cierto código después de un retraso específico o después de un período de tiempo determinado. 

		    Esto es útil para tareas programadas y animaciones.


		Manejo de Errores Personalizados:

		    Cuando ocurre un error en una función, puedes utilizar un callback para especificar cómo manejar ese error de manera personalizada. 

		    Por ejemplo, puedes proporcionar una función de callback que se ejecute cuando se produzca un error de red.


		Validación de Datos Personalizada:

		    En la validación de datos, puedes usar callbacks para especificar cómo validar un dato en particular. 

		    Esto permite que el código de validación sea altamente personalizable y se adapte a diferentes requisitos.


		Orden Superior (Higher-Order Functions):

		    En programación funcional, puedes usar callbacks como argumentos para funciones de orden superior, como map, filter y reduce. 

		    Esto permite aplicar funciones personalizadas a elementos de una lista o realizar filtrado basado en criterios específicos.


		Manejo de Excepciones Personalizado:

		    Puedes utilizar callbacks para definir cómo manejar excepciones personalizadas en tu código. 

		    Por ejemplo, puedes proporcionar una función de callback que se llame cuando se genere una excepción específica.


		Personalización de Comportamiento de Bibliotecas y Frameworks:

		    Muchas bibliotecas y frameworks permiten utilizar callbacks para personalizar su comportamiento. 

		    Por ejemplo, en un framework de juegos, puedes proporcionar una función de callback para definir cómo se manejan los eventos de colisión.


		Programación Asíncrona y Paralela:

		    En programación asíncrona y paralela, los callbacks se utilizan para especificar qué hacer cuando una tarea asíncrona se completa, lo que permite un control preciso del flujo de la aplicación.



|| BUILT-IN FUNCTION

	Son funciones integradas en Python son predefinidas que forman parte del lenguaje y están disponibles para su uso en cualquier momento, sin necesidad de importar módulos adicionales. 

	Estas funciones proporcionan funcionalidades básicas y esenciales que cubren una amplia gama de tareas comunes en la programación.


	print(): Muestra información en la consola.

	```python

		print("Hola, mundo!")
	
	```

	len(): Devuelve la longitud (cantidad de elementos) de una secuencia (cadena, lista, tupla, etc.).

	```python

		nombre = "Alice"
		longitud_nombre = len(nombre)  # longitud_nombre = 5

	```

	input(): Lee una entrada del usuario desde la consola.

	```python

		entrada = input("Ingresa tu nombre: ")

	```

	int(), float(), str(), list(), tuple(), dict(), set(): Convierten entre tipos de datos.

	```python

		numero_texto = "42"
		numero = int(numero_texto)

	```

	range(): Genera una secuencia de números en un rango especificado.

	```python

		numeros = range(1, 6)  # Genera una secuencia: 1, 2, 3, 4, 5

	```

	sum(), max(), min(): Calculan la suma, el valor máximo y el valor mínimo de una secuencia de números.

	```python

		numeros = [5, 2, 8, 1, 6]
		suma_total = sum(numeros)  # suma_total = 22
		valor_maximo = max(numeros)  # valor_maximo = 8
		valor_minimo = min(numeros)  # valor_minimo = 1

	```

	sorted(): Ordena una secuencia de elementos.

	```python

		numeros = [5, 2, 8, 1, 6]
		numeros_ordenados = sorted(numeros)  # numeros_ordenados = [1, 2, 5, 6, 8]

	```

	abs(): Devuelve el valor absoluto de un número.

	```python

		valor_negativo = -5
		valor_absoluto = abs(valor_negativo)  # valor_absoluto = 5

	```

	Lista de funciones incorporadas: 

		Funciones de Conversión de Datos:

		    int(): Convierte a entero.

		    float(): Convierte a punto flotante.

		    str(): Convierte a cadena.

		    bool(): Convierte a booleano.

		    list(): Convierte a lista.

		    tuple(): Convierte a tupla.

		    set(): Convierte a conjunto.

		    dict(): Convierte a diccionario.


		Funciones de Iterables:

		    len(): Devuelve la longitud de un iterable.

		    max(): Devuelve el valor máximo en un iterable.

		    min(): Devuelve el valor mínimo en un iterable.

		    sum(): Calcula la suma de los elementos en un iterable.


		Funciones de Secuencia:

		    range(): Genera una secuencia de números.

		    enumerate(): Devuelve índices y elementos de un iterable.

		    zip(): Combina varios iterables en tuplas.


		Funciones de Entrada/Salida:

		    print(): Muestra texto en la consola.

		    input(): Lee la entrada del usuario desde la consola.

		    open(): Abre archivos para lectura o escritura.


		Funciones Matemáticas y Numéricas:

		    abs(): Valor absoluto.

		    round(): Redondea un número.

		    pow(): Potencia.

		    divmod(): Divide y devuelve el cociente y el resto.

		    hex(): Convierte a representación hexadecimal.

		    oct(): Convierte a representación octal.


		Funciones de Listas, Tuplas y Conjuntos:

		    sorted(): Ordena elementos en un iterable.

		    reversed(): Invierte un iterable.

		    any(): Devuelve True si algún elemento es verdadero.

		    all(): Devuelve True si todos los elementos son verdaderos.


		Funciones de Cadenas:

		    len(): Devuelve la longitud de una cadena.

		    str(): Convierte a cadena.

		    join(): Une elementos de una lista en una cadena.

		    split(): Divide una cadena en una lista de subcadenas.


		Funciones de Diccionarios:

		    len(): Devuelve la cantidad de pares clave-valor en un diccionario.

		    keys(): Devuelve las claves como una vista.

		    values(): Devuelve los valores como una vista.

		    items(): Devuelve los pares clave-valor como una vista.

		    get(): Obtiene el valor asociado a una clave.

		    pop(): Elimina y devuelve el valor asociado a una clave.


		Funciones de Control de Flujo:

		    if: Estructura condicional.

		    for: Bucle de iteración.

		    while: Bucle de control.


		Funciones de Manejo de Excepciones:

		    try, except: Captura y maneja excepciones.

		    raise: Genera una excepción




|| ESTRUCTURAS DE DATOS




|| ESTRUCTURAS DE DATOS AVANZADOS




|| RegEx




|| DECORATORS 




|| ITERADORES 




|| MÓDULOS 






